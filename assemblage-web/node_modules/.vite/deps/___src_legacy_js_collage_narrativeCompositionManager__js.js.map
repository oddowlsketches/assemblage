{
  "version": 3,
  "sources": ["../../../src/legacy/js/collage/narrativeCompositionManager.js"],
  "sourcesContent": ["/**\n * Narrative Composition Manager for Assemblage\n * Manages the narrative flow and composition of collage elements\n */\n\nexport class NarrativeCompositionManager {\n    constructor(parameters = {}) {\n        this.parameters = {\n            ...parameters,\n            canvasWidth: parameters.canvasWidth || window.innerWidth,\n            canvasHeight: parameters.canvasHeight || window.innerHeight\n        };\n    }\n\n    adjustOpacity(fragment, progress, depthOpacity = false) {\n        fragment.opacity = 0.85 + (Math.sin(progress * Math.PI) * 0.15); // Higher base opacity\n\n        if (depthOpacity) {\n            const minOpacity = 0.5; // Increased from 0.3\n            const maxOpacity = 1.0;\n            fragment.opacity = minOpacity + ((maxOpacity - minOpacity) * (1 - fragment.depth));\n        }\n    }\n\n    createHexagonMask(element) {\n        const width = element.width;\n        const height = element.height;\n        const centerX = width / 2;\n        const centerY = height / 2;\n        const radius = Math.min(width, height) / 2;\n        \n        // Calculate vertices for a regular hexagon\n        const vertices = [];\n        for (let i = 0; i < 6; i++) {\n            const angle = (i * Math.PI / 3) - Math.PI / 6; // Start from flat top\n            vertices.push({\n                x: centerX + radius * Math.cos(angle),\n                y: centerY + radius * Math.sin(angle)\n            });\n        }\n        \n        // Create the mask path\n        const path = new Path2D();\n        path.moveTo(vertices[0].x, vertices[0].y);\n        for (let i = 1; i < vertices.length; i++) {\n            path.lineTo(vertices[i].x, vertices[i].y);\n        }\n        path.closePath();\n        \n        // Store mask parameters for later use\n        element.maskParams = {\n            type: 'hexagon',\n            vertices: vertices,\n            centerX: centerX,\n            centerY: centerY,\n            radius: radius\n        };\n        \n        return path;\n    }\n\n    createArcMask(element) {\n        const width = element.width;\n        const height = element.height;\n        const centerX = width / 2;\n        const centerY = height / 2;\n        \n        // Calculate arc parameters\n        const arcRadius = Math.min(width, height) / 2;\n        const arcWidth = Math.max(30, arcRadius * 0.2); // Ensure minimum width of 30px\n        \n        // Create the mask path\n        const path = new Path2D();\n        \n        // Draw a single arc path\n        path.arc(centerX, centerY, arcRadius, 0, Math.PI * 2);\n        \n        // Create a clipping region\n        const clipPath = new Path2D();\n        clipPath.rect(0, 0, width, height);\n        \n        // Store mask parameters for later use\n        element.maskParams = {\n            type: 'arc',\n            centerX: centerX,\n            centerY: centerY,\n            radius: arcRadius,\n            width: arcWidth\n        };\n        \n        return {\n            path: path,\n            clipPath: clipPath\n        };\n    }\n\n    async generate(images, fortuneText, effect, parameters = {}) {\n        // Clear canvas and set background\n        const ctx = this.parameters.ctx;\n        const canvas = this.parameters.canvas;\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        \n        // Generate layered composition\n        const fragments = [];\n        const numLayers = Math.min(images.length, 4); // Use up to 4 layers\n        \n        for (let i = 0; i < numLayers; i++) {\n            const image = images[i];\n            if (!image || !image.complete) continue;\n            \n            // Calculate layer dimensions\n            const scale = 0.8 + (i * 0.1); // Each layer slightly larger\n            const width = canvas.width * scale;\n            const height = canvas.height * scale;\n            \n            // Center the layer\n            const x = (canvas.width - width) / 2;\n            const y = (canvas.height - height) / 2;\n            \n            // Create fragment with mask\n            const fragment = {\n                image,\n                x,\n                y,\n                width,\n                height,\n                depth: i / numLayers,\n                opacity: 0.7 + (i * 0.1)\n            };\n            \n            // Apply mask based on layer\n            if (i % 2 === 0) {\n                fragment.mask = this.createHexagonMask(fragment);\n            } else {\n                fragment.mask = this.createArcMask(fragment);\n            }\n            \n            fragments.push(fragment);\n        }\n        \n        // Draw fragments\n        fragments.forEach(fragment => {\n            ctx.save();\n            ctx.globalAlpha = fragment.opacity;\n            \n            if (fragment.mask) {\n                if (fragment.mask.path && fragment.mask.clipPath) {\n                    ctx.clip(fragment.mask.clipPath);\n                    ctx.drawImage(fragment.image, fragment.x, fragment.y, fragment.width, fragment.height);\n                } else {\n                    ctx.clip(fragment.mask);\n                    ctx.drawImage(fragment.image, fragment.x, fragment.y, fragment.width, fragment.height);\n                }\n            } else {\n                ctx.drawImage(fragment.image, fragment.x, fragment.y, fragment.width, fragment.height);\n            }\n            \n            ctx.restore();\n        });\n        \n        return fragments;\n    }\n} "],
  "mappings": "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",
  "names": []
}
