{
  "version": 3,
  "sources": ["../../../src/legacy/js/collage/crystalFormationGenerator.js"],
  "sourcesContent": ["/**\n * Crystal Formation Generator for Assemblage\n * Creates seamless crystal-like collage structures with interconnected facets\n */\n\nexport class CrystalFormationGenerator {\n    constructor(ctx, canvas) {\n        if (!ctx || !canvas) {\n            throw new Error('Both canvas context and canvas element are required');\n        }\n        \n        this.ctx = ctx;\n        this.canvas = canvas;\n        \n        // Validate canvas dimensions\n        if (!this.canvas.width || !this.canvas.height) {\n            console.warn('Canvas dimensions not set, using window dimensions');\n            this.canvas.width = window.innerWidth;\n            this.canvas.height = window.innerHeight;\n        }\n\n        // Validate context properties\n        if (!this.ctx.fillStyle || !this.ctx.globalCompositeOperation) {\n            throw new Error('Canvas context missing required properties');\n        }\n\n        // Define crystal angles for more realistic formations\n        this.crystalAngles = [60, 90, 120];\n        \n        // Define seed point distribution patterns\n        this.seedPatterns = {\n            radial: (centerX, centerY, radius, count) => {\n                const points = [];\n                for (let i = 0; i < count; i++) {\n                    const angle = (i / count) * Math.PI * 2;\n                    const distance = radius * (0.5 + Math.random() * 0.5); // More even distribution\n                    points.push({\n                        x: centerX + Math.cos(angle) * distance,\n                        y: centerY + Math.sin(angle) * distance\n                    });\n                }\n                return points;\n            },\n            grid: (centerX, centerY, radius, count) => {\n                const points = [];\n                const gridSize = Math.ceil(Math.sqrt(count));\n                const cellSize = (radius * 2) / gridSize;\n                \n                for (let i = 0; i < gridSize; i++) {\n                    for (let j = 0; j < gridSize; j++) {\n                        if (points.length >= count) break;\n                        \n                        const x = centerX - radius + (i + 0.5) * cellSize;\n                        const y = centerY - radius + (j + 0.5) * cellSize;\n                        \n                        // Add some randomness to avoid perfect grid\n                        const offsetX = (Math.random() - 0.5) * cellSize * 0.5;\n                        const offsetY = (Math.random() - 0.5) * cellSize * 0.5;\n                        \n                        points.push({\n                            x: x + offsetX,\n                            y: y + offsetY\n                        });\n                    }\n                }\n                return points;\n            },\n            random: (centerX, centerY, radius, count) => {\n                const points = [];\n                for (let i = 0; i < count; i++) {\n                    const angle = Math.random() * Math.PI * 2;\n                    const distance = radius * Math.random();\n                    points.push({\n                        x: centerX + Math.cos(angle) * distance,\n                        y: centerY + Math.sin(angle) * distance\n                    });\n                }\n                return points;\n            },\n            clusters: (centerX, centerY, radius, count) => {\n                const points = [];\n                const numClusters = Math.max(3, Math.floor(count / 5));\n                const pointsPerCluster = Math.ceil(count / numClusters);\n                \n                for (let c = 0; c < numClusters; c++) {\n                    const clusterAngle = (c / numClusters) * Math.PI * 2;\n                    const clusterDistance = radius * (0.3 + Math.random() * 0.4);\n                    const clusterX = centerX + Math.cos(clusterAngle) * clusterDistance;\n                    const clusterY = centerY + Math.sin(clusterAngle) * clusterDistance;\n                    \n                    const clusterRadius = radius * 0.2;\n                    for (let i = 0; i < pointsPerCluster; i++) {\n                        if (points.length >= count) break;\n                        const angle = Math.random() * Math.PI * 2;\n                        const distance = clusterRadius * Math.random();\n                        points.push({\n                            x: clusterX + Math.cos(angle) * distance,\n                            y: clusterY + Math.sin(angle) * distance\n                        });\n                    }\n                }\n                return points;\n            },\n            spiral: (centerX, centerY, radius, count) => {\n                const points = [];\n                const spiralTightness = 0.3;\n                for (let i = 0; i < count; i++) {\n                    const t = i / count;\n                    const angle = t * Math.PI * 8;\n                    const distance = radius * (0.2 + t * 0.8);\n                    points.push({\n                        x: centerX + Math.cos(angle) * distance * (1 - spiralTightness * t),\n                        y: centerY + Math.sin(angle) * distance * (1 - spiralTightness * t)\n                    });\n                }\n                return points;\n            }\n        };\n    }\n\n    generateBackgroundColor() {\n        // Rich, vibrant colors that work well with multiply blend mode\n        const colors = [\n            '#FF6B6B', // Coral Red\n            '#4ECDC4', // Turquoise\n            '#45B7D1', // Sky Blue\n            '#96CEB4', // Sage Green\n            '#FFEEAD', // Cream\n            '#D4A5A5', // Dusty Rose\n            '#9B59B6', // Purple\n            '#3498DB', // Blue\n            '#E67E22', // Orange\n            '#2ECC71'  // Green\n        ];\n        return colors[Math.floor(Math.random() * colors.length)];\n    }\n\n    async generateCrystal(images, fortuneText, parameters = {}) {\n        console.log('Starting crystal generation with parameters:', parameters);\n        console.log('Number of input images:', images.length);\n\n        // Store parameters for use in other methods\n        this.parameters = parameters;\n\n        // Clear canvas and set background\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        this.ctx.fillStyle = this.generateBackgroundColor();\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n        // Filter out invalid images\n        const validImages = images.filter(img => {\n            const isValid = img && img.complete && img.naturalWidth > 0 && img.naturalHeight > 0;\n            if (!isValid) {\n                console.warn('Invalid image found:', {\n                    complete: img?.complete,\n                    naturalWidth: img?.naturalWidth,\n                    naturalHeight: img?.naturalHeight\n                });\n            }\n            return isValid;\n        });\n\n        console.log('Number of valid images:', validImages.length);\n\n        if (validImages.length === 0) {\n            console.error('No valid images provided for crystal generation');\n            return false;\n        }\n\n        try {\n            // Determine complexity and seed pattern\n            const complexity = parameters.complexity || 5;\n            const seedPattern = parameters.seedPattern || this.getRandomSeedPattern();\n            \n            console.log('Using complexity:', complexity, 'and seed pattern:', seedPattern);\n\n            // Calculate number of facets based on complexity\n            const facetCount = Math.min(\n                Math.max(5, Math.floor(complexity * 3)),\n                parameters.maxFacets || 25\n            );\n\n            console.log('Creating crystal formation with', facetCount, 'facets');\n\n            // Create the crystal formation\n            const fragments = this.createCrystalFormation(facetCount, validImages, seedPattern, parameters);\n            \n            // Set multiply blend mode before drawing fragments\n            this.ctx.globalCompositeOperation = 'multiply';\n            \n            // Draw the fragments\n            console.log('Drawing', fragments.length, 'fragments');\n            this.drawFragments(fragments);\n            \n            // Reset blend mode\n            this.ctx.globalCompositeOperation = 'source-over';\n            \n            console.log('Crystal generation completed successfully');\n            return true;\n        } catch (error) {\n            console.error('Error in crystal generation:', error);\n            return false;\n        }\n    }\n\n    getRandomSeedPattern() {\n        const patterns = Object.keys(this.seedPatterns);\n        return patterns[Math.floor(Math.random() * patterns.length)];\n    }\n\n    createCrystalFormation(facetCount, images, seedPattern, parameters) {\n        const fragments = [];\n        const centerX = this.canvas.width / 2;\n        const centerY = this.canvas.height / 2;\n        \n        // Use the full canvas diagonal as the base size to ensure coverage\n        const baseSize = Math.sqrt(Math.pow(this.canvas.width, 2) + Math.pow(this.canvas.height, 2));\n        \n        // Generate seed points for Voronoi diagram\n        const seedPoints = this.generateSeedPoints(centerX, centerY, baseSize / 2, facetCount, seedPattern);\n        \n        // Create Voronoi cells\n        const cells = this.createVoronoiCells(seedPoints, centerX, centerY, baseSize);\n        \n        // Process cells to create facets\n        cells.forEach((cell, index) => {\n            // Skip cells that are too small or degenerate\n            if (cell.vertices.length < 3) return;\n            \n            // Create facet from cell\n            const facet = this.createFacetFromCell(cell, images[index % images.length], index);\n            fragments.push(facet);\n        });\n        \n        // Refine edges to ensure seamless connections\n        this.refineFacetEdges(fragments);\n        \n        return fragments;\n    }\n\n    generateSeedPoints(centerX, centerY, baseSize, count, pattern) {\n        // Determine if we should include a center point based on pattern and random chance\n        const includeCenter = pattern === 'radial' || (pattern === 'grid' && Math.random() < 0.5);\n        \n        // Start with center point if needed\n        const points = includeCenter ? [{ x: centerX, y: centerY }] : [];\n        \n        // Generate additional points using the specified pattern\n        const radius = baseSize / 2;\n        const additionalPoints = this.seedPatterns[pattern](centerX, centerY, radius, count - (includeCenter ? 1 : 0));\n        \n        return [...points, ...additionalPoints];\n    }\n\n    createVoronoiCells(points, centerX, centerY, baseSize) {\n        // Simple implementation of Voronoi diagram using Fortune's algorithm\n        // For simplicity, we'll use a grid-based approach to approximate Voronoi cells\n        \n        const cells = [];\n        const gridSize = 50; // Resolution of the grid\n        const cellSize = baseSize / gridSize;\n        \n        // Create a grid of points\n        const grid = [];\n        for (let i = 0; i <= gridSize; i++) {\n            for (let j = 0; j <= gridSize; j++) {\n                const x = centerX - baseSize/2 + i * cellSize;\n                const y = centerY - baseSize/2 + j * cellSize;\n                grid.push({ x, y });\n            }\n        }\n        \n        // Assign each grid point to the nearest seed point\n        const assignments = new Map();\n        grid.forEach(point => {\n            let minDist = Infinity;\n            let nearestSeedIndex = 0;\n            \n            points.forEach((seed, index) => {\n                const dist = this.distance(point, seed);\n                if (dist < minDist) {\n                    minDist = dist;\n                    nearestSeedIndex = index;\n                }\n            });\n            \n            assignments.set(`${point.x},${point.y}`, nearestSeedIndex);\n        });\n        \n        // Create cells by grouping grid points assigned to the same seed\n        points.forEach((seed, seedIndex) => {\n            const cellPoints = grid.filter(point => \n                assignments.get(`${point.x},${point.y}`) === seedIndex\n            );\n            \n            if (cellPoints.length > 0) {\n                // Find the convex hull of the cell points\n                const vertices = this.convexHull(cellPoints);\n                cells.push({\n                    center: seed,\n                    vertices: vertices,\n                    seedIndex: seedIndex\n                });\n            }\n        });\n        \n        return cells;\n    }\n\n    distance(p1, p2) {\n        return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));\n    }\n\n    convexHull(points) {\n        // Graham scan algorithm for convex hull\n        if (points.length < 3) return points;\n        \n        // Find the point with the lowest y-coordinate (and leftmost if tied)\n        let lowest = 0;\n        for (let i = 1; i < points.length; i++) {\n            if (points[i].y < points[lowest].y || \n                (points[i].y === points[lowest].y && points[i].x < points[lowest].x)) {\n                lowest = i;\n            }\n        }\n        \n        // Swap the lowest point to the beginning\n        const temp = points[0];\n        points[0] = points[lowest];\n        points[lowest] = temp;\n        \n        // Sort the rest of the points by polar angle with respect to the lowest point\n        const p0 = points[0];\n        points.sort((a, b) => {\n            const angleA = Math.atan2(a.y - p0.y, a.x - p0.x);\n            const angleB = Math.atan2(b.y - p0.y, b.x - p0.x);\n            if (angleA === angleB) {\n                return this.distance(p0, a) - this.distance(p0, b);\n            }\n            return angleA - angleB;\n        });\n        \n        // Build the convex hull\n        const hull = [points[0], points[1]];\n        for (let i = 2; i < points.length; i++) {\n            while (hull.length >= 2 && \n                   this.crossProduct(\n                       hull[hull.length - 2],\n                       hull[hull.length - 1],\n                       points[i]\n                   ) <= 0) {\n                hull.pop();\n            }\n            hull.push(points[i]);\n        }\n        \n        return hull;\n    }\n\n    crossProduct(p1, p2, p3) {\n        return (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);\n    }\n\n    createFacetFromCell(cell, image, index) {\n        // Calculate center of the facet\n        const centerX = cell.center.x;\n        const centerY = cell.center.y;\n        \n        // Calculate bounding box\n        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n        cell.vertices.forEach(vertex => {\n            minX = Math.min(minX, vertex.x);\n            minY = Math.min(minY, vertex.y);\n            maxX = Math.max(maxX, vertex.x);\n            maxY = Math.max(maxY, vertex.y);\n        });\n        \n        const width = maxX - minX;\n        const height = maxY - minY;\n        \n        // Calculate rotation based on cell position and rotationRange parameter\n        const rotationRange = this.parameters?.rotationRange || 15;\n        const rotation = Math.random() * rotationRange * 2 - rotationRange; // Random rotation within the specified range\n        \n        // Calculate opacity based on distance from center\n        const centerDistance = this.distance(\n            { x: this.canvas.width / 2, y: this.canvas.height / 2 },\n            { x: centerX, y: centerY }\n        );\n        const maxDistance = Math.min(this.canvas.width, this.canvas.height) / 2;\n        const opacity = 0.7 + 0.3 * (1 - centerDistance / maxDistance);\n        \n        return {\n            image: image,\n            x: centerX,\n            y: centerY,\n            width: width,\n            height: height,\n            rotation: rotation,\n            opacity: opacity,\n            vertices: cell.vertices,\n            seedIndex: cell.seedIndex,\n            isFacet: true,\n            facetIndex: index\n        };\n    }\n\n    refineFacetEdges(fragments) {\n        // Ensure adjacent facets share exact edge coordinates\n        // This is a simplified approach - in a full implementation, we would\n        // detect shared edges and ensure they have identical coordinates\n        \n        // For now, we'll just ensure all vertices are properly aligned to the grid\n        fragments.forEach(fragment => {\n            if (fragment.vertices) {\n                fragment.vertices = fragment.vertices.map(vertex => ({\n                    x: Math.round(vertex.x),\n                    y: Math.round(vertex.y)\n                }));\n            }\n        });\n    }\n\n    drawFragments(fragments) {\n        // Sort fragments by distance from center for proper layering\n        const centerX = this.canvas.width / 2;\n        const centerY = this.canvas.height / 2;\n        \n        fragments.sort((a, b) => {\n            const distA = this.distance(\n                { x: centerX, y: centerY },\n                { x: a.x, y: a.y }\n            );\n            const distB = this.distance(\n                { x: centerX, y: centerY },\n                { x: b.x, y: b.y }\n            );\n            return distA - distB;\n        });\n\n        // Draw each fragment\n        fragments.forEach(fragment => {\n            this.drawFragment(fragment);\n        });\n    }\n\n    drawFragment(fragment) {\n        if (!fragment.image || !fragment.image.complete) return;\n\n        this.ctx.save();\n\n        // Use the fragment's opacity or calculate based on global settings\n        const baseOpacity = this.parameters?.blendOpacity || 0.45;\n        const opacityVariation = 0.15;\n        const randomOpacity = baseOpacity + (Math.random() * 2 * opacityVariation) - opacityVariation;\n        // If this is the first fragment (index 0), set to full opacity\n        const finalOpacity = fragment.facetIndex === 0 ? 1.0 : Math.max(0.3, Math.min(0.6, randomOpacity));\n        \n        this.ctx.globalAlpha = fragment.opacity || finalOpacity;\n        // Don't set blend mode here - use the global setting from CollageGenerator\n\n        // Translate to fragment position\n        this.ctx.translate(fragment.x, fragment.y);\n        this.ctx.rotate(fragment.rotation * Math.PI / 180);\n\n        // Create clipping path based on vertices\n        if (fragment.vertices && fragment.vertices.length >= 3) {\n            this.ctx.beginPath();\n            this.ctx.moveTo(\n                fragment.vertices[0].x - fragment.x,\n                fragment.vertices[0].y - fragment.y\n            );\n            \n            for (let i = 1; i < fragment.vertices.length; i++) {\n                this.ctx.lineTo(\n                    fragment.vertices[i].x - fragment.x,\n                    fragment.vertices[i].y - fragment.y\n                );\n            }\n            \n            this.ctx.closePath();\n            this.ctx.clip();\n        }\n\n        // Draw the image\n        const imgAspectRatio = fragment.image.naturalWidth / fragment.image.naturalHeight;\n        const fragmentAspectRatio = fragment.width / fragment.height;\n\n        let drawWidth, drawHeight;\n        if (imgAspectRatio > fragmentAspectRatio) {\n            drawHeight = fragment.height;\n            drawWidth = drawHeight * imgAspectRatio;\n        } else {\n            drawWidth = fragment.width;\n            drawHeight = drawWidth / imgAspectRatio;\n        }\n\n        this.ctx.drawImage(\n            fragment.image,\n            -drawWidth / 2,\n            -drawHeight / 2,\n            drawWidth,\n            drawHeight\n        );\n\n        this.ctx.restore();\n    }\n}\n\nexport class SafeCrystalFormationGenerator {\n    constructor(ctx, canvas) {\n        try {\n            if (!ctx || !canvas) {\n                throw new Error('Both canvas context and canvas element are required');\n            }\n\n            // Validate canvas dimensions\n            if (!canvas.width || !canvas.height) {\n                console.warn('Canvas dimensions not set, using window dimensions');\n                canvas.width = window.innerWidth;\n                canvas.height = window.innerHeight;\n            }\n\n            // Validate context properties\n            if (!ctx.fillStyle || !ctx.globalCompositeOperation) {\n                throw new Error('Canvas context missing required properties');\n            }\n\n            this.generator = new CrystalFormationGenerator(ctx, canvas);\n            this.isValid = true;\n            console.log('SafeCrystalFormationGenerator initialized successfully');\n        } catch (error) {\n            console.error('Failed to initialize CrystalFormationGenerator:', error);\n            this.isValid = false;\n        }\n    }\n\n    async generateCrystal(images, fortuneText, parameters = {}) {\n        if (!this.isValid) {\n            console.warn('CrystalFormationGenerator is not in a valid state');\n            return false;\n        }\n\n        if (!Array.isArray(images) || images.length === 0) {\n            console.error('No images provided to generateCrystal');\n            return false;\n        }\n\n        try {\n            console.log('SafeCrystalFormationGenerator starting crystal generation');\n            const result = await this.generator.generateCrystal(images, fortuneText, parameters);\n            console.log('SafeCrystalFormationGenerator completed crystal generation:', result);\n            return result;\n        } catch (error) {\n            console.error('Error in crystal generation:', error);\n            return false;\n        }\n    }\n} "],
  "mappings": "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",
  "names": []
}
