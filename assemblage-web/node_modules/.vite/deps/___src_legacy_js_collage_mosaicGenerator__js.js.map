{
  "version": 3,
  "sources": ["../../../src/legacy/js/collage/mosaicGenerator.js"],
  "sourcesContent": ["/**\n * MosaicGenerator class for creating mosaic-style collages\n * This class handles the generation of mosaic-style collages with various composition styles\n */\nclass MosaicGenerator {\n    /**\n     * Create a new MosaicGenerator\n     * @param {HTMLCanvasElement} canvas - The canvas to draw on\n     * @param {Object} parameters - Parameters for mosaic generation\n     */\n    constructor(canvas, parameters = {}) {\n        this.canvas = canvas;\n        this.ctx = canvas ? canvas.getContext('2d') : null;\n        this.parameters = parameters;\n        \n        // Set default canvas dimensions if not provided\n        if (!this.canvas) {\n            this.canvas = {\n                width: 1200,\n                height: 800\n            };\n        }\n        \n        // Ensure canvas has dimensions\n        if (!this.canvas.width || !this.canvas.height) {\n            this.canvas.width = 1200;\n            this.canvas.height = 800;\n        }\n    }\n\n    /**\n     * Shuffle an array using Fisher-Yates algorithm\n     * @param {Array} array - The array to shuffle\n     * @returns {Array} - The shuffled array\n     */\n    shuffleArray(array) {\n        const shuffled = [...array];\n        for (let i = shuffled.length - 1; i > 0; i--) {\n            const j = Math.floor(Math.random() * (i + 1));\n            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n        }\n        return shuffled;\n    }\n\n    /**\n     * Generate a mosaic collage\n     * @param {Array} images - Array of image objects\n     * @param {Object} parameters - Parameters for mosaic generation\n     * @returns {Promise<void>}\n     */\n    async generateMosaic(images, parameters = {}) {\n        if (!images || images.length === 0) {\n            console.warn('No images provided for mosaic generation');\n            return [];\n        }\n\n        try {\n            // Calculate grid size based on number of images and complexity\n            const complexity = parameters.complexity || 0.5;\n            const baseGridSize = Math.ceil(Math.sqrt(images.length));\n            \n            // Create more varied tile sizes\n            let gridSize;\n            const rand = Math.random();\n            if (rand < 0.2) { // 20% chance for very large tiles\n                gridSize = Math.floor(Math.random() * 2) + 2; // 2-3 rows\n            } else if (rand < 0.4) { // 20% chance for large tiles\n                gridSize = Math.floor(Math.random() * 2) + 4; // 4-5 rows\n            } else if (rand < 0.7) { // 30% chance for medium tiles\n                gridSize = Math.floor(Math.random() * 2) + 6; // 6-7 rows\n            } else { // 30% chance for smaller tiles\n                gridSize = Math.max(8, Math.min(10, Math.ceil(baseGridSize * (1 + complexity))));\n            }\n            \n            // Calculate cell dimensions\n            const cellWidth = this.canvas.width / gridSize;\n            const cellHeight = this.canvas.height / gridSize;\n            \n            // Create shuffled array of image indices\n            const imageIndices = this.shuffleArray([...Array(images.length).keys()]);\n            let currentIndex = 0;\n            \n            // Determine how many tiles should have full opacity (at least 40%)\n            const totalTiles = gridSize * gridSize;\n            const fullOpacityCount = Math.max(1, Math.ceil(totalTiles * 0.4));\n            const fullOpacityTiles = new Array(totalTiles).fill(false);\n            \n            // Randomly select tiles for full opacity\n            for (let i = 0; i < fullOpacityCount; i++) {\n                const randomIndex = Math.floor(Math.random() * totalTiles);\n                fullOpacityTiles[randomIndex] = true;\n            }\n            \n            // Determine if tiles should touch without overlap\n            const tilesTouching = parameters.tilesTouching || false;\n            \n            // Array to store fragment information\n            const fragments = [];\n            \n            // Apply composition style\n            if (parameters.compositionStyle === 'Focal') {\n                // For Focal style, create larger cells towards the center\n                const centerX = this.canvas.width / 2;\n                const centerY = this.canvas.height / 2;\n                \n                for (let i = 0; i < gridSize; i++) {\n                    for (let j = 0; j < gridSize; j++) {\n                        const x = i * cellWidth;\n                        const y = j * cellHeight;\n                        \n                        // Calculate distance from center\n                        const dx = x - centerX;\n                        const dy = y - centerY;\n                        const distance = Math.sqrt(dx * dx + dy * dy);\n                        const maxDistance = Math.sqrt(centerX * centerX + centerY * centerY);\n                        \n                        // Scale cell size based on distance from center\n                        // If tiles are touching, use a smaller scale factor to prevent overlap\n                        const scaleFactor = tilesTouching ? 0.5 : 1.0;\n                        const scale = 1 + (1 - distance / maxDistance) * 0.5 * scaleFactor;\n                        \n                        // Select image based on repetition setting\n                        let imageIndex;\n                        if (parameters.allowImageRepetition) {\n                            imageIndex = Math.floor(Math.random() * images.length);\n                        } else {\n                            imageIndex = imageIndices[currentIndex % imageIndices.length];\n                            currentIndex++;\n                        }\n                        const image = images[imageIndex];\n                        \n                        // Calculate tile index for opacity assignment\n                        const tileIndex = i * gridSize + j;\n                        \n                        // Determine opacity - at least 70% for all tiles, 100% for selected tiles\n                        const opacity = fullOpacityTiles[tileIndex] ? 1.0 : 0.7 + Math.random() * 0.3;\n                        \n                        // Determine if this tile should show a cropped portion of the image\n                        // 40% chance of showing a cropped portion\n                        const showCroppedPortion = Math.random() < 0.4;\n                        \n                        // Calculate final position and dimensions\n                        const finalX = x - (cellWidth * scale - cellWidth) / 2;\n                        const finalY = y - (cellHeight * scale - cellHeight) / 2;\n                        const finalWidth = cellWidth * scale;\n                        const finalHeight = cellHeight * scale;\n                        \n                        // Draw cell with scaled dimensions and proper cropping\n                        this.drawImage(\n                            image,\n                            finalX,\n                            finalY,\n                            finalWidth,\n                            finalHeight,\n                            true,\n                            opacity,\n                            showCroppedPortion\n                        );\n                        \n                        // Store fragment information\n                        fragments.push({\n                            image,\n                            x: finalX,\n                            y: finalY,\n                            width: finalWidth,\n                            height: finalHeight,\n                            opacity,\n                            showCroppedPortion\n                        });\n                    }\n                }\n            } else {\n                // For Field style, create more uniform cells with slight variations\n                for (let i = 0; i < gridSize; i++) {\n                    for (let j = 0; j < gridSize; j++) {\n                        const x = i * cellWidth;\n                        const y = j * cellHeight;\n                        \n                        // Add slight randomness to cell position and size\n                        // If tiles are touching, use smaller offsets to prevent overlap\n                        const offsetFactor = tilesTouching ? 0.05 : 0.1;\n                        const offsetX = (Math.random() - 0.5) * cellWidth * offsetFactor;\n                        const offsetY = (Math.random() - 0.5) * cellHeight * offsetFactor;\n                        \n                        // Scale factor for tile size\n                        const scaleFactor = tilesTouching ? 0.2 : 0.2;\n                        const scale = 1 + (Math.random() - 0.5) * scaleFactor;\n                        \n                        // Select image based on repetition setting\n                        let imageIndex;\n                        if (parameters.allowImageRepetition) {\n                            imageIndex = Math.floor(Math.random() * images.length);\n                        } else {\n                            imageIndex = imageIndices[currentIndex % imageIndices.length];\n                            currentIndex++;\n                        }\n                        const image = images[imageIndex];\n                        \n                        // Calculate tile index for opacity assignment\n                        const tileIndex = i * gridSize + j;\n                        \n                        // Determine opacity - at least 70% for all tiles, 100% for selected tiles\n                        const opacity = fullOpacityTiles[tileIndex] ? 1.0 : 0.7 + Math.random() * 0.3;\n                        \n                        // Determine if this tile should show a cropped portion of the image\n                        // 40% chance of showing a cropped portion\n                        const showCroppedPortion = Math.random() < 0.4;\n                        \n                        // Calculate final position and dimensions\n                        const finalX = x + offsetX;\n                        const finalY = y + offsetY;\n                        const finalWidth = cellWidth * scale;\n                        const finalHeight = cellHeight * scale;\n                        \n                        // Draw cell with slight variations and proper cropping\n                        this.drawImage(\n                            image,\n                            finalX,\n                            finalY,\n                            finalWidth,\n                            finalHeight,\n                            true,\n                            opacity,\n                            showCroppedPortion\n                        );\n                        \n                        // Store fragment information\n                        fragments.push({\n                            image,\n                            x: finalX,\n                            y: finalY,\n                            width: finalWidth,\n                            height: finalHeight,\n                            opacity,\n                            showCroppedPortion\n                        });\n                    }\n                }\n            }\n            \n            // Return the array of fragments\n            return fragments;\n        } catch (error) {\n            console.error('Error generating mosaic:', error);\n            return [];\n        }\n    }\n\n    /**\n     * Draw an image with optional cropping and opacity\n     * @param {HTMLImageElement} image - The image to draw\n     * @param {number} x - X position\n     * @param {number} y - Y position\n     * @param {number} width - Width of the destination rectangle\n     * @param {number} height - Height of the destination rectangle\n     * @param {boolean} crop - Whether to crop the image\n     * @param {number} forceOpacity - Forced opacity value (0-1)\n     * @param {boolean} showCroppedPortion - Whether to show a cropped portion\n     * @param {number} rotation - Rotation angle in degrees\n     */\n    drawImage(image, x, y, width, height, crop = false, forceOpacity = null, showCroppedPortion = false, rotation = 0) {\n        if (!this.ctx || !image) return;\n\n        // Save the current context state\n        this.ctx.save();\n\n        // Set opacity\n        const opacity = forceOpacity !== null ? forceOpacity : 1;\n        this.ctx.globalAlpha = opacity;\n\n        // Move to the center of where we want to draw\n        this.ctx.translate(x + width/2, y + height/2);\n        \n        // Rotate if specified\n        if (rotation) {\n            this.ctx.rotate(rotation * Math.PI / 180);\n        }\n\n        // Move back by half the width/height\n        this.ctx.translate(-width/2, -height/2);\n\n        if (showCroppedPortion) {\n            // Calculate random crop coordinates\n            const cropX = Math.random() * (image.width - width);\n            const cropY = Math.random() * (image.height - height);\n            \n            // Draw the cropped portion\n            this.ctx.drawImage(\n                image,\n                cropX, cropY, width, height,\n                0, 0, width, height\n            );\n        } else {\n            // Draw the full image\n            this.ctx.drawImage(image, 0, 0, width, height);\n        }\n\n        // Restore the context state\n        this.ctx.restore();\n    }\n}\n\n// Export the MosaicGenerator class\nexport { MosaicGenerator }; "],
  "mappings": "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",
  "names": []
}
