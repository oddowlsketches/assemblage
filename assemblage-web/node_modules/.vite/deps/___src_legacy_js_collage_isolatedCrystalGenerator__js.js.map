{
  "version": 3,
  "sources": ["../../../src/legacy/js/collage/isolatedCrystalGenerator.js"],
  "sourcesContent": ["/**\n * Isolated Crystal Generator for Assemblage\n * Creates crystal formations with negative space around them\n */\n\nimport { SafeCrystalFormationGenerator } from './crystalFormationGenerator.js';\n\nexport class IsolatedCrystalGenerator {\n    constructor(ctx, canvas) {\n        // Store context and canvas\n        this.ctx = ctx;\n        this.canvas = canvas;\n        \n        // Initialize canvas dimensions if not set\n        if (!this.canvas.width || !this.canvas.height) {\n            this.canvas.width = window.innerWidth;\n            this.canvas.height = window.innerHeight;\n        }\n        \n        // For accessing the high-quality facet creation methods\n        this.crystalGenerator = new SafeCrystalFormationGenerator(ctx, canvas);\n        \n        // Define crystal outline templates\n        this.crystalTemplates = {\n            hexagonal: (centerX, centerY, size) => {\n                const points = [];\n                const sides = 6;\n                for (let i = 0; i < sides; i++) {\n                    const angle = (i * 2 * Math.PI / sides) - (Math.PI / 2);\n                    points.push({\n                        x: centerX + size * Math.cos(angle),\n                        y: centerY + size * Math.sin(angle)\n                    });\n                }\n                return points;\n            },\n            irregular: (centerX, centerY, size) => {\n                const points = [];\n                const sides = 5 + Math.floor(Math.random() * 3); // 5-7 sides\n                for (let i = 0; i < sides; i++) {\n                    const angle = (i * 2 * Math.PI / sides) - (Math.PI / 2);\n                    const variance = 0.8 + Math.random() * 0.4; // 80-120% of size\n                    points.push({\n                        x: centerX + size * variance * Math.cos(angle),\n                        y: centerY + size * variance * Math.sin(angle)\n                    });\n                }\n                return points;\n            },\n            angular: (centerX, centerY, size) => {\n                const points = [];\n                const sides = 4;\n                for (let i = 0; i < sides; i++) {\n                    const angle = (i * 2 * Math.PI / sides) - (Math.PI / 4);\n                    const variance = 0.9 + Math.random() * 0.2; // 90-110% of size\n                    points.push({\n                        x: centerX + size * variance * Math.cos(angle),\n                        y: centerY + size * variance * Math.sin(angle)\n                    });\n                    // Add intermediate point for more angular look\n                    const midAngle = angle + (Math.PI / sides);\n                    const midVariance = 0.4 + Math.random() * 0.3; // 40-70% of size\n                    points.push({\n                        x: centerX + size * midVariance * Math.cos(midAngle),\n                        y: centerY + size * midVariance * Math.sin(midAngle)\n                    });\n                }\n                return points;\n            },\n            elongated: (centerX, centerY, size) => {\n                const points = [];\n                const verticalStretch = 1.5;\n                const sides = 6;\n                for (let i = 0; i < sides; i++) {\n                    const angle = (i * 2 * Math.PI / sides) - (Math.PI / 2);\n                    points.push({\n                        x: centerX + size * Math.cos(angle),\n                        y: centerY + size * verticalStretch * Math.sin(angle)\n                    });\n                }\n                return points;\n            }\n        };\n\n        this.seedPatterns = {\n            radial: (centerX, centerY, radius, count) => {\n                const points = [];\n                for (let i = 0; i < count; i++) {\n                    const angle = (i / count) * Math.PI * 2;\n                    const distance = radius * (0.3 + Math.random() * 0.7);\n                    points.push({\n                        x: centerX + Math.cos(angle) * distance,\n                        y: centerY + Math.sin(angle) * distance\n                    });\n                }\n                return points;\n            },\n            grid: (centerX, centerY, radius, count) => {\n                const points = [];\n                const gridSize = Math.ceil(Math.sqrt(count));\n                const cellSize = (radius * 2) / gridSize;\n                \n                for (let i = 0; i < gridSize; i++) {\n                    for (let j = 0; j < gridSize; j++) {\n                        if (points.length >= count) break;\n                        \n                        const x = centerX - radius + (i + 0.5) * cellSize;\n                        const y = centerY - radius + (j + 0.5) * cellSize;\n                        \n                        // Add some randomness to avoid perfect grid\n                        const offsetX = (Math.random() - 0.5) * cellSize * 0.5;\n                        const offsetY = (Math.random() - 0.5) * cellSize * 0.5;\n                        \n                        points.push({\n                            x: x + offsetX,\n                            y: y + offsetY\n                        });\n                    }\n                }\n                return points;\n            },\n            random: (centerX, centerY, radius, count) => {\n                const points = [];\n                for (let i = 0; i < count; i++) {\n                    const angle = Math.random() * Math.PI * 2;\n                    const distance = radius * Math.random();\n                    points.push({\n                        x: centerX + Math.cos(angle) * distance,\n                        y: centerY + Math.sin(angle) * distance\n                    });\n                }\n                return points;\n            },\n            clusters: (centerX, centerY, radius, count) => {\n                const points = [];\n                const numClusters = Math.ceil(count / 5);\n                const pointsPerCluster = Math.ceil(count / numClusters);\n                \n                for (let i = 0; i < numClusters; i++) {\n                    const clusterCenter = {\n                        x: centerX + (Math.random() - 0.5) * radius,\n                        y: centerY + (Math.random() - 0.5) * radius\n                    };\n                    const clusterRadius = radius * 0.2;\n                    \n                    for (let j = 0; j < pointsPerCluster; j++) {\n                        if (points.length >= count) break;\n                        const angle = Math.random() * Math.PI * 2;\n                        const distance = clusterRadius * Math.random();\n                        points.push({\n                            x: clusterCenter.x + Math.cos(angle) * distance,\n                            y: clusterCenter.y + Math.sin(angle) * distance\n                        });\n                    }\n                }\n                return points;\n            },\n            spiral: (centerX, centerY, radius, count) => {\n                const points = [];\n                const spiralTightness = 0.3;\n                const spiralGrowth = radius / count;\n                \n                for (let i = 0; i < count; i++) {\n                    const angle = i * spiralTightness;\n                    const distance = spiralGrowth * i;\n                    points.push({\n                        x: centerX + Math.cos(angle) * distance,\n                        y: centerY + Math.sin(angle) * distance\n                    });\n                }\n                return points;\n            }\n        };\n\n        // Set default parameters\n        this.parameters = {\n            complexity: 5,\n            maxFacets: 25,\n            blendOpacity: 0.7,\n            addGlow: false, // Disabled by default\n            template: 'hexagonal',\n            crystalSize: 0.6, // Changed from 0.8 to 0.6 (60% of canvas)\n            crystalCount: 1, // Number of crystals to generate in a field\n            preventOverlap: true, // Prevent crystals from overlapping\n            imageMode: null, // Set to null by default to allow proper parameter passing\n            facetBorders: true, // Whether to draw subtle borders around facets\n            enableVisualEffects: true, // Add subtle visual effects to enhance quality\n            fullscreen: false // Whether to fill the entire screen (no UI elements)\n        };\n\n        console.log('IsolatedCrystalGenerator initialized with canvas dimensions:', {\n            width: this.canvas.width,\n            height: this.canvas.height\n        });\n    }\n\n    generateBackgroundColor() {\n        // Generate a vibrant background color\n        const colors = [\n            '#FF6B6B', // Coral Red\n            '#4ECDC4', // Turquoise\n            '#45B7D1', // Sky Blue\n            '#96CEB4', // Sage Green\n            '#FFEEAD', // Cream\n            '#D4A5A5', // Dusty Rose\n            '#9B59B6', // Purple\n            '#3498DB', // Blue\n            '#E67E22', // Orange\n            '#2ECC71'  // Green\n        ];\n        return colors[Math.floor(Math.random() * colors.length)];\n    }\n\n    async generateIsolatedCrystal(image, parameters = {}) {\n        console.log('[DEBUG] generateIsolatedCrystal starting with incoming params:', parameters);\n        \n        // Process parameters with direct assignment of incoming parameters\n        // Use parameters directly without fallbacks to ensure randomization\n        this.parameters = {\n            ...this.parameters, // Keep defaults for missing parameters\n            complexity: parameters.complexity,\n            maxFacets: parameters.maxFacets,\n            blendOpacity: parameters.blendOpacity,\n            addGlow: parameters.addGlow,\n            imageMode: parameters.imageMode,\n            seedPattern: parameters.seedPattern,\n            crystalSize: parameters.crystalSize,\n            crystalCount: parameters.crystalCount,\n            preventOverlap: parameters.preventOverlap,\n            facetBorders: parameters.facetBorders,\n            enableVisualEffects: parameters.enableVisualEffects,\n            template: parameters.template\n        };\n\n        // Force randomization of critical parameters if they're missing\n        if (this.parameters.complexity === undefined) {\n            this.parameters.complexity = 0.3 + Math.random() * 0.4; // 0.3-0.7\n            console.log('[DEBUG] Forced random complexity:', this.parameters.complexity);\n        }\n        \n        if (!this.parameters.imageMode) {\n            this.parameters.imageMode = Math.random() < 0.5 ? 'unique' : 'single';\n            console.log('[DEBUG] Forced random imageMode:', this.parameters.imageMode);\n        }\n        \n        if (!this.parameters.maxFacets) {\n            this.parameters.maxFacets = 6 + Math.floor(Math.random() * 19); // 6-24\n            console.log('[DEBUG] Forced random maxFacets:', this.parameters.maxFacets);\n        }\n        \n        if (!this.parameters.seedPattern) {\n            const patterns = Object.keys(this.seedPatterns);\n            this.parameters.seedPattern = patterns[Math.floor(Math.random() * patterns.length)];\n            console.log('[DEBUG] Forced random seedPattern:', this.parameters.seedPattern);\n        }\n\n        console.log('[DEBUG] Processed parameters:', this.parameters);\n\n        // Clear canvas and set background\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        this.ctx.fillStyle = this.generateBackgroundColor();\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n        // Filter out invalid images\n        const validImages = image.filter(img => {\n            if (!img) {\n                console.warn('Null or undefined image found');\n                return false;\n            }\n            return img.complete && img.naturalWidth > 0 && img.naturalHeight > 0;\n        });\n\n        console.log('Number of valid images:', validImages.length);\n\n        if (validImages.length === 0) {\n            console.error('No valid images provided for crystal generation');\n            return false;\n        }\n\n        try {\n            // Determine if we're generating a single crystal or a field\n            if (this.parameters.crystalCount > 1) {\n                // Generate a field of crystals\n                console.log(`Generating crystal field with ${this.parameters.crystalCount} crystals`);\n                await this.generateCrystalField(validImages);\n            } else {\n                // Generate a single crystal\n                console.log('Generating single crystal');\n                await this.generateSingleCrystal(validImages);\n            }\n\n            return true;\n        } catch (error) {\n            console.error('Error generating crystal:', error);\n            return false;\n        }\n    }\n    \n    // Generate a single crystal\n    async generateSingleCrystal(images) {\n        // Calculate crystal center (use canvas center)\n        const centerX = this.canvas.width / 2;\n        const centerY = this.canvas.height / 2;\n        \n        // Calculate maximum size that ensures crystal stays within canvas with margins\n        const margin = 30; // Fixed 30px margin\n        const maxWidth = this.canvas.width - 2 * margin;\n        const maxHeight = this.canvas.height - 2 * margin;\n        \n        // Calculate the maximum size that would fit within the canvas\n        const maxCanvasSize = Math.min(maxWidth, maxHeight);\n        \n        // Force crystal size to 45% of canvas size\n        const maxParamSize = Math.min(this.canvas.width, this.canvas.height) * 0.45;\n        \n        // Use the smaller of the two to ensure it fits\n        const maxSize = Math.min(maxCanvasSize, maxParamSize);\n        \n        // Ensure the crystal center is within the safe area\n        const safeCenterX = Math.max(margin + maxSize/2, Math.min(this.canvas.width - margin - maxSize/2, centerX));\n        const safeCenterY = Math.max(margin + maxSize/2, Math.min(this.canvas.height - margin - maxSize/2, centerY));\n        \n        console.log(`Crystal size calculation: maxCanvasSize=${maxCanvasSize}, maxParamSize=${maxParamSize}, final maxSize=${maxSize}`);\n        console.log(`Adjusted center position: (${safeCenterX}, ${safeCenterY})`);\n        \n        // Get crystal outline using the selected template\n        // Force random template selection to ensure variety\n        const templateName = this.getRandomTemplate();\n        console.log(`[DEBUG] FORCED random template selected: ${templateName}`);\n        \n        const templateFunc = this.crystalTemplates[templateName];\n        if (!templateFunc) {\n            console.error(`Template ${templateName} not found`);\n            return false;\n        }\n        \n        // Generate the crystal outline points\n        const crystalOutline = templateFunc(safeCenterX, safeCenterY, maxSize);\n        \n        if (!crystalOutline || crystalOutline.length < 3) {\n            console.error('Invalid crystal outline generated');\n            return false;\n        }\n        \n        console.log(`Created crystal outline with ${crystalOutline.length} points`);\n        \n        // Calculate number of facets based on complexity - ensure wide range of facets\n        // Make calculation more randomized to ensure variety\n        const baseCount = Math.max(6, Math.floor(this.parameters.maxFacets * this.parameters.complexity));\n        const facetCount = baseCount + Math.floor(Math.random() * 10); // Add additional randomization\n        console.log(`[DEBUG] Generating crystal with ${facetCount} facets (complexity: ${this.parameters.complexity}, maxFacets: ${this.parameters.maxFacets})`);\n        \n        \n        // Generate facets within the crystal boundary\n        const fragments = await this.generateFacetsWithinBoundary(\n            facetCount,\n            images,\n            crystalOutline\n        );\n        \n        console.log(`Generated ${fragments.length} facets`);\n\n        // Handle image selection based on imageMode\n        console.log('Handling image selection with mode:', this.parameters.imageMode);\n\n        if (this.parameters.imageMode === 'single' && images.length > 0) {\n            // Select one random image for all facets\n            const selectedImageIndex = Math.floor(Math.random() * images.length);\n            const selectedImage = images[selectedImageIndex];\n            \n            console.log(`Single image mode: Using image ${selectedImageIndex} for all facets`);\n            \n            fragments.forEach(fragment => {\n                fragment.image = selectedImage;\n                fragment.imageIndex = selectedImageIndex;\n            });\n        } else {\n            // In unique mode, assign random images to each facet\n            console.log('Unique mode: Assigning random images to each facet');\n            fragments.forEach(fragment => {\n                const imageIndex = Math.floor(Math.random() * images.length);\n                fragment.image = images[imageIndex];\n                fragment.imageIndex = imageIndex;\n            });\n        }\n\n        // Set blend mode and draw fragments\n        this.ctx.globalCompositeOperation = 'multiply';\n        this.drawFragments(fragments);\n        this.ctx.globalCompositeOperation = 'source-over';\n        \n        return true;\n    }\n    \n    // Generate a field of crystals\n    async generateCrystalField(images) {\n        // Calculate crystal positions based on count\n        const positions = this.generateCrystalPositions(\n            this.parameters.crystalCount,\n            this.parameters.preventOverlap\n        );\n        \n        console.log(`Generated ${positions.length} crystal positions`);\n        \n        // Generate each crystal\n        for (const position of positions) {\n            // Select template for this crystal\n            const template = this.getRandomTemplate();\n            \n            // Generate crystal at this position\n            await this.generateSingleCrystal(images, {\n                centerX: position.x,\n                centerY: position.y,\n                crystalSize: position.size,\n                template: template,\n                imageMode: this.parameters.imageMode // Pass through the imageMode parameter\n            });\n        }\n        \n        return true;\n    }\n    \n    // Generate positions for multiple crystals\n    generateCrystalPositions(count, preventOverlap) {\n        const positions = [];\n        const canvasWidth = this.canvas.width;\n        const canvasHeight = this.canvas.height;\n        \n        // Calculate base size based on count and ensure 30px margin\n        const margin = 30; // Fixed 30px margin\n        const maxWidth = canvasWidth - 2 * margin;\n        const maxHeight = canvasHeight - 2 * margin;\n        \n        // Calculate the maximum size that would fit within the canvas\n        const maxCanvasSize = Math.min(maxWidth, maxHeight);\n        \n        // Calculate the maximum size based on the crystalSize parameter\n        const maxParamSize = Math.min(canvasWidth, canvasHeight) * this.parameters.crystalSize;\n        \n        // Use the smaller of the two to ensure it fits\n        const maxSize = Math.min(maxCanvasSize, maxParamSize);\n        \n        // Calculate base size for multiple crystals\n        const baseSize = Math.max(0.1, Math.min(maxSize / Math.min(canvasWidth, canvasHeight), 0.6 / Math.sqrt(count)));\n        \n        console.log(`Multiple crystal size calculation: maxCanvasSize=${maxCanvasSize}, maxParamSize=${maxParamSize}, maxSize=${maxSize}, baseSize=${baseSize}`);\n        \n        const minDistanceBetween = Math.min(canvasWidth, canvasHeight) * baseSize * (preventOverlap ? 1.2 : 0.8);\n        \n        // First crystal is always centered for consistency\n        if (count > 0) {\n            positions.push({\n                x: canvasWidth / 2,\n                y: canvasHeight / 2,\n                size: baseSize * (0.8 + Math.random() * 0.4)\n            });\n        }\n        \n        // Try to place remaining crystals\n        let attempts = 0;\n        const maxAttempts = count * 100;\n        \n        while (positions.length < count && attempts < maxAttempts) {\n            // Generate random position with margin from edges\n            const x = margin + Math.random() * (canvasWidth - 2 * margin);\n            const y = margin + Math.random() * (canvasHeight - 2 * margin);\n            \n            // Random size variation (80-120% of base size)\n            const size = baseSize * (0.8 + Math.random() * 0.4);\n            \n            // Check if this position is valid\n            let isValid = true;\n            \n            if (preventOverlap) {\n                // Check distance from all existing crystals\n                for (const pos of positions) {\n                    const dx = pos.x - x;\n                    const dy = pos.y - y;\n                    const distance = Math.sqrt(dx * dx + dy * dy);\n                    \n                    // Calculate minimum required distance (sum of radii with safety margin)\n                    const minDistance = (pos.size + size) * minDistanceBetween;\n                    \n                    if (distance < minDistance) {\n                        isValid = false;\n                        break;\n                    }\n                }\n            }\n            \n            if (isValid) {\n                positions.push({ x, y, size });\n            }\n            \n            attempts++;\n        }\n        \n        console.log(`Created ${positions.length} crystal positions after ${attempts} attempts`);\n        \n        return positions;\n    }\n\n    getRandomTemplate() {\n        const templates = Object.keys(this.crystalTemplates);\n        return templates[Math.floor(Math.random() * templates.length)];\n    }\n    \n    // Helper: Check if a point is inside a polygon\n    isPointInPolygon(point, polygon) {\n        if (!polygon || polygon.length < 3) return false;\n        \n        let inside = false;\n        \n        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n            const xi = polygon[i].x;\n            const yi = polygon[i].y;\n            const xj = polygon[j].x;\n            const yj = polygon[j].y;\n            \n            const intersect = ((yi > point.y) !== (yj > point.y)) &&\n                (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);\n                \n            if (intersect) inside = !inside;\n        }\n        \n        return inside;\n    }\n    \n    // Helper: Get bounding box of a polygon\n    getBounds(points) {\n        if (!points || points.length === 0) return { x: 0, y: 0, width: 0, height: 0 };\n        \n        let minX = Infinity, minY = Infinity;\n        let maxX = -Infinity, maxY = -Infinity;\n        \n        points.forEach(point => {\n            minX = Math.min(minX, point.x);\n            minY = Math.min(minY, point.y);\n            maxX = Math.max(maxX, point.x);\n            maxY = Math.max(maxY, point.y);\n        });\n        \n        return {\n            x: minX,\n            y: minY,\n            width: maxX - minX,\n            height: maxY - minY\n        };\n    }\n    \n    // Generate seed points within the crystal boundary \n    generateSeedPointsWithinBoundary(centerX, centerY, radius, count, patternType) {\n        console.log(`Generating ${count} seed points with pattern: ${patternType}`);\n        \n        // Start with an empty array for seed points\n        let seedPoints = [];\n        \n        // Get the pattern function\n        const patternFunc = this.seedPatterns[patternType];\n        if (!patternFunc) {\n            console.error(`Pattern function for '${patternType}' not found`);\n            return seedPoints;\n        }\n        \n        // Generate more points than we need, we'll filter them later\n        const extraPoints = patternFunc(centerX, centerY, radius, count * 2);\n        console.log(`Generated ${extraPoints.length} candidate seed points`);\n        \n        // Filter points to only include those within the crystal outline\n        for (let point of extraPoints) {\n            if (seedPoints.length >= count) break; // Stop once we have enough points\n            \n            // Add this point if it's within the boundary\n            seedPoints.push(point);\n        }\n        \n        console.log(`Returning ${seedPoints.length} filtered seed points`);\n        return seedPoints;\n    }\n    \n    // Generate crystal facets within a specified boundary using Voronoi diagram principles\n    async generateFacetsWithinBoundary(facetCount, images, crystalOutline) {\n        if (!crystalOutline || crystalOutline.length < 3) {\n            console.error('Invalid crystal outline provided');\n            return [];\n        }\n        \n        // Get bounds of the crystal outline\n        const bounds = this.getBounds(crystalOutline);\n        const centerX = bounds.x + bounds.width / 2;\n        const centerY = bounds.y + bounds.height / 2;\n        const radius = Math.max(bounds.width, bounds.height) / 2;\n        \n        // Add safety margin to ensure facets stay within bounds\n        const safetyMargin = 20; // Increased from 15px to 20px for better safety\n        const adjustedBounds = {\n            x: bounds.x + safetyMargin,\n            y: bounds.y + safetyMargin,\n            width: bounds.width - 2 * safetyMargin,\n            height: bounds.height - 2 * safetyMargin\n        };\n        \n        console.log(`Creating facets within boundary - center: (${centerX}, ${centerY}), radius: ${radius}`);\n        console.log('Adjusted bounds with safety margin:', adjustedBounds);\n\n        // Generate seed points within the crystal boundary\n        const seedPattern = this.parameters.seedPattern || 'random';\n        \n        // Generate more seed points than needed to ensure we have enough after filtering\n        const extraFacetCount = Math.min(facetCount * 2, 80); // Cap at 80 to avoid performance issues\n        \n        // Use the appropriate seed pattern function to generate points\n        const initialPoints = this.seedPatterns[seedPattern](centerX, centerY, radius * 0.75, extraFacetCount); // Reduced from 0.85 to 0.75 for more compact facets\n        \n        // Add center point for more balanced facets\n        initialPoints.push({x: centerX, y: centerY});\n        \n        // Filter points to ensure they're inside the crystal boundary with safety margin\n        const seedPoints = initialPoints.filter(point => {\n            // First check if point is within the adjusted bounds\n            const withinBounds = point.x >= adjustedBounds.x && \n                               point.x <= adjustedBounds.x + adjustedBounds.width &&\n                               point.y >= adjustedBounds.y && \n                               point.y <= adjustedBounds.y + adjustedBounds.height;\n            \n            // Then check if it's within the crystal outline\n            return withinBounds && this.isPointInPolygon(point, crystalOutline);\n        });\n        \n        // Ensure we have enough points (at least 80% of target)\n        if (seedPoints.length < Math.max(5, facetCount * 0.8)) {\n            console.warn(`Not enough seed points after filtering: ${seedPoints.length}/${facetCount}. Adding more points.`);\n            \n            // Add random points within the polygon boundary\n            for (let i = seedPoints.length; i < facetCount; i++) {\n                // Attempt to add a point up to 10 times\n                for (let attempt = 0; attempt < 10; attempt++) {\n                    // Generate random point within adjusted bounds\n                    const rx = adjustedBounds.x + Math.random() * adjustedBounds.width;\n                    const ry = adjustedBounds.y + Math.random() * adjustedBounds.height;\n                    \n                    if (this.isPointInPolygon({x: rx, y: ry}, crystalOutline)) {\n                        seedPoints.push({x: rx, y: ry});\n                        break;\n                    }\n                }\n            }\n        }\n        \n        console.log(`Using ${seedPoints.length} seed points for Voronoi generation`);\n        \n        // Create a grid to approximate Voronoi cells\n        const gridResolution = Math.max(30, Math.min(100, facetCount * 2)); // Higher resolution for smoother facets\n        const cells = this.createVoronoiCellsFromGrid(seedPoints, crystalOutline, gridResolution);\n        \n        console.log(`Created ${cells.length} Voronoi cells`);\n        \n        // Create fragments from Voronoi cells\n        const fragments = [];\n        \n        for (let i = 0; i < cells.length; i++) {\n            const cell = cells[i];\n            \n            // Skip cells with too few vertices\n            if (!cell.vertices || cell.vertices.length < 3) continue;\n            \n            // Ensure all vertices are within the crystal outline\n            const validVertices = cell.vertices.filter(vertex => \n                this.isPointInPolygon(vertex, crystalOutline)\n            );\n            \n            // Skip if we lost too many vertices\n            if (validVertices.length < 3) continue;\n            \n            // Calculate distance from center for visual effects\n            const dx = cell.center.x - centerX;\n            const dy = cell.center.y - centerY;\n            const distanceFromCenter = Math.sqrt(dx * dx + dy * dy);\n            const normalizedDistance = Math.min(1, distanceFromCenter / radius);\n            \n            // Calculate opacity based on distance from center (inner facets more opaque)\n            const opacity = 0.4 + 0.6 * (1 - normalizedDistance * 0.8);\n            \n            // Small random rotation for natural look\n            const rotation = (Math.random() * 20 - 10) * (1 - normalizedDistance * 0.7);\n            \n            // Get bounding box of vertices for sizing\n            const vertexBounds = this.getBounds(validVertices);\n            const facetSize = Math.max(vertexBounds.width, vertexBounds.height);\n            \n            fragments.push({\n                vertices: validVertices,\n                x: cell.center.x,\n                y: cell.center.y,\n                opacity: opacity,\n                rotation: rotation,\n                size: facetSize\n            });\n        }\n        \n        return fragments;\n    }\n    \n    // Create Voronoi cells from a grid-based approach\n    createVoronoiCellsFromGrid(seedPoints, crystalOutline, resolution = 50) {\n        if (!seedPoints || seedPoints.length === 0) {\n            return [];\n        }\n        \n        // Get bounds of the crystal outline\n        const bounds = this.getBounds(crystalOutline);\n        \n        // Create a grid within the bounds\n        const cellWidth = bounds.width / resolution;\n        const cellHeight = bounds.height / resolution;\n        \n        // Initialize grid with empty point assignments\n        const grid = [];\n        \n        // Assign each grid point to the nearest seed point\n        for (let x = 0; x < resolution; x++) {\n            for (let y = 0; y < resolution; y++) {\n                // Calculate actual position\n                const px = bounds.x + x * cellWidth + cellWidth / 2;\n                const py = bounds.y + y * cellHeight + cellHeight / 2;\n                \n                // Only process points within the crystal outline\n                if (!this.isPointInPolygon({x: px, y: py}, crystalOutline)) {\n                    continue;\n                }\n                \n                // Find the nearest seed point\n                let minDist = Infinity;\n                let nearestSeed = -1;\n                \n                for (let i = 0; i < seedPoints.length; i++) {\n                    const seed = seedPoints[i];\n                    const dx = px - seed.x;\n                    const dy = py - seed.y;\n                    const dist = dx * dx + dy * dy; // No need for square root for comparison\n                    \n                    if (dist < minDist) {\n                        minDist = dist;\n                        nearestSeed = i;\n                    }\n                }\n                \n                if (nearestSeed >= 0) {\n                    grid.push({x: px, y: py, seedIndex: nearestSeed});\n                }\n            }\n        }\n        \n        // Group grid points by seed index\n        const pointsBySeed = {};\n        \n        for (const point of grid) {\n            if (!pointsBySeed[point.seedIndex]) {\n                pointsBySeed[point.seedIndex] = [];\n            }\n            pointsBySeed[point.seedIndex].push({x: point.x, y: point.y});\n        }\n        \n        // Create cells from grouped points\n        const cells = [];\n        \n        for (let i = 0; i < seedPoints.length; i++) {\n            const points = pointsBySeed[i];\n            \n            if (!points || points.length < 5) { // Need enough points for a meaningful shape\n                continue;\n            }\n            \n            // Create convex hull for cell boundary\n            const hull = this.getConvexHull(points);\n            \n            if (hull.length >= 3) { // Valid polygon\n                cells.push({\n                    center: seedPoints[i],\n                    vertices: hull,\n                    seedIndex: i\n                });\n            }\n        }\n        \n        return cells;\n    }\n    \n    // Get convex hull of points (Graham scan algorithm)\n    getConvexHull(points) {\n        // Need at least 3 points to form a polygon\n        if (!points || points.length < 3) {\n            return points || [];\n        }\n        \n        // Find point with lowest y-coordinate (leftmost if tied)\n        let lowestPoint = 0;\n        for (let i = 1; i < points.length; i++) {\n            if (points[i].y < points[lowestPoint].y || \n               (points[i].y === points[lowestPoint].y && points[i].x < points[lowestPoint].x)) {\n                lowestPoint = i;\n            }\n        }\n        \n        // Swap the lowest point to position 0\n        [points[0], points[lowestPoint]] = [points[lowestPoint], points[0]];\n        \n        // Sort points by polar angle with respect to lowest point\n        const p0 = points[0];\n        \n        points.sort((a, b) => {\n            if (a === p0) return -1;\n            if (b === p0) return 1;\n            \n            // Calculate polar angles\n            const theta1 = Math.atan2(a.y - p0.y, a.x - p0.x);\n            const theta2 = Math.atan2(b.y - p0.y, b.x - p0.x);\n            \n            if (theta1 === theta2) {\n                // If angles are the same, sort by distance\n                const dist1 = Math.pow(a.x - p0.x, 2) + Math.pow(a.y - p0.y, 2);\n                const dist2 = Math.pow(b.x - p0.x, 2) + Math.pow(b.y - p0.y, 2);\n                return dist1 - dist2;\n            }\n            \n            return theta1 - theta2;\n        });\n        \n        // Build the hull\n        const hull = [points[0], points[1]];\n        \n        for (let i = 2; i < points.length; i++) {\n            while (hull.length >= 2 && !this.isLeftTurn(hull[hull.length - 2], hull[hull.length - 1], points[i])) {\n                hull.pop();\n            }\n            hull.push(points[i]);\n        }\n        \n        return hull;\n    }\n    \n    // Check if three points make a left turn\n    isLeftTurn(p1, p2, p3) {\n        // Cross product to determine turn direction\n        return (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x) > 0;\n    }\n    \n    // Draw the fragments\n    drawFragments(fragments) {\n        if (!fragments || fragments.length === 0) return;\n        \n        console.log(`Drawing ${fragments.length} fragments`);\n        \n        // Sort fragments by distance from center for proper layering\n        const centerX = this.canvas.width / 2;\n        const centerY = this.canvas.height / 2;\n        \n        fragments.sort((a, b) => {\n            const distA = Math.sqrt(Math.pow(a.x - centerX, 2) + Math.pow(a.y - centerY, 2));\n            const distB = Math.sqrt(Math.pow(b.x - centerX, 2) + Math.pow(b.y - centerY, 2));\n            return distA - distB; // Draw from center outward\n        });\n        \n        // Draw each fragment\n        fragments.forEach(fragment => {\n            this.drawFragment(fragment);\n        });\n    }\n    \n    // Draw a single fragment with improved visual quality\n    drawFragment(fragment) {\n        if (!fragment.image || !fragment.image.complete) {\n            console.warn('Attempted to draw fragment with invalid image');\n            return;\n        }\n        \n        this.ctx.save();\n        \n        // Set opacity with slight variation for visual depth\n        const baseOpacity = fragment.opacity || this.parameters.blendOpacity;\n        // Add tiny random variation for more natural look\n        const finalOpacity = baseOpacity * (0.9 + Math.random() * 0.2); \n        this.ctx.globalAlpha = finalOpacity;\n        \n        // Move to the fragment position\n        this.ctx.translate(fragment.x, fragment.y);\n        \n        // Apply rotation - convert degrees to radians\n        if (fragment.rotation) {\n            this.ctx.rotate((fragment.rotation * Math.PI) / 180);\n        }\n        \n        // Create clipping path using the fragment's vertices\n        if (fragment.vertices && fragment.vertices.length >= 3) {\n            this.ctx.beginPath();\n            \n            // Move to the first vertex\n            this.ctx.moveTo(\n                fragment.vertices[0].x - fragment.x,\n                fragment.vertices[0].y - fragment.y\n            );\n            \n            // Draw lines to the remaining vertices\n            for (let i = 1; i < fragment.vertices.length; i++) {\n                this.ctx.lineTo(\n                    fragment.vertices[i].x - fragment.x,\n                    fragment.vertices[i].y - fragment.y\n                );\n            }\n            \n            this.ctx.closePath();\n            \n            // Create a subtle border around each facet for definition\n            if (this.parameters.facetBorders !== false) {\n                // Draw a very subtle stroke around the facet\n                this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.05)';\n                this.ctx.lineWidth = 0.5;\n                this.ctx.stroke();\n            }\n            \n            // Apply the clipping path\n            this.ctx.clip();\n        }\n        \n        // Calculate how to draw the image with improved sizing\n        const imgWidth = fragment.image.naturalWidth;\n        const imgHeight = fragment.image.naturalHeight;\n        const imgRatio = imgWidth / imgHeight;\n        \n        // Calculate the size of the fragment\n        let facetWidth = fragment.size;\n        let facetHeight = fragment.size;\n        \n        if (!facetWidth || !facetHeight) {\n            // If width/height not explicitly set, calculate from bounding box\n            if (fragment.vertices && fragment.vertices.length >= 3) {\n                // Find the bounding box of vertices\n                let minX = Infinity, minY = Infinity;\n                let maxX = -Infinity, maxY = -Infinity;\n                \n                for (const vertex of fragment.vertices) {\n                    const vx = vertex.x - fragment.x;\n                    const vy = vertex.y - fragment.y;\n                    minX = Math.min(minX, vx);\n                    minY = Math.min(minY, vy);\n                    maxX = Math.max(maxX, vx);\n                    maxY = Math.max(maxY, vy);\n                }\n                \n                facetWidth = maxX - minX;\n                facetHeight = maxY - minY;\n            } else {\n                // Fallback to default size\n                facetWidth = facetHeight = 100;\n            }\n        }\n        \n        // Scale the image to cover the facet completely\n        let drawWidth, drawHeight;\n        \n        if (imgRatio > 1) {\n            // Image is wider than tall\n            drawHeight = Math.max(facetWidth, facetHeight) * 1.2;\n            drawWidth = drawHeight * imgRatio;\n        } else {\n            // Image is taller than wide\n            drawWidth = Math.max(facetWidth, facetHeight) * 1.2;\n            drawHeight = drawWidth / imgRatio;\n        }\n        \n        // Draw the image centered on the fragment position\n        this.ctx.drawImage(\n            fragment.image,\n            -drawWidth / 2,\n            -drawHeight / 2,\n            drawWidth,\n            drawHeight\n        );\n        \n        this.ctx.restore();\n    }\n}"],
  "mappings": "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",
  "names": []
}
