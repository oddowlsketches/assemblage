{
  "version": 3,
  "sources": ["../../../src/legacy/js/collage/slicedCollageGenerator.js"],
  "sourcesContent": ["/**\n * Sliced Collage Generator for Assemblage\n * Handles sliced-specific collage generation with enhanced parameters\n */\n\nexport class SlicedCollageGenerator {\n    constructor(ctx, canvas) {\n        this.ctx = ctx;\n        this.canvas = canvas;\n        \n        // Set default canvas dimensions if not provided\n        if (!this.canvas) {\n            this.canvas = {\n                width: 1200,\n                height: 800\n            };\n        }\n        \n        // Ensure canvas has dimensions\n        if (!this.canvas.width || !this.canvas.height) {\n            this.canvas.width = 1200;\n            this.canvas.height = 800;\n        }\n    }\n\n    generateBackgroundColor() {\n        // Array of vibrant background colors\n        const colors = [\n            '#FF6B6B', // Coral Red\n            '#4ECDC4', // Turquoise\n            '#45B7D1', // Sky Blue\n            '#96CEB4', // Sage Green\n            '#FFEEAD', // Cream\n            '#D4A5A5', // Dusty Rose\n            '#9B59B6', // Purple\n            '#3498DB', // Blue\n            '#E67E22', // Orange\n            '#2ECC71'  // Green\n        ];\n        return colors[Math.floor(Math.random() * colors.length)];\n    }\n\n    // Calculate required scale for an image based on target dimensions\n    calculateRequiredScale(image, targetWidth, targetHeight, minVisibility = 0.7) {\n        const imgRatio = image.naturalWidth / image.naturalHeight;\n        const targetRatio = targetWidth / targetHeight;\n        \n        let scale;\n        if (imgRatio > targetRatio) {\n            // Image is wider than target\n            scale = targetHeight / image.naturalHeight;\n        } else {\n            // Image is taller than target\n            scale = targetWidth / image.naturalWidth;\n        }\n        \n        // Account for minimum visibility requirement\n        const minScale = Math.max(\n            minVisibility / imgRatio,\n            minVisibility * imgRatio\n        );\n        \n        return Math.max(scale, minScale);\n    }\n\n    async generateSliced(images, fortuneText, parameters = {}) {\n        // Clear canvas and set background\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        this.ctx.fillStyle = this.generateBackgroundColor();\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n        // Filter out invalid images\n        const validImages = images.filter(img => img && img.complete && img.naturalWidth > 0 && img.naturalHeight > 0);\n\n        if (validImages.length === 0) {\n            console.warn('No valid images provided for sliced generation');\n            return [];\n        }\n\n        // Determine slice behavior\n        const sliceBehavior = parameters.sliceBehavior || 'random';\n        let selectedImage = null;\n        let secondImage = null;\n        \n        console.log('Slice behavior:', sliceBehavior);\n        \n        // Calculate number of slices based on behavior\n        let numSlices;\n        if (sliceBehavior === 'random') {\n            // For random images, use 3-7 slices\n            numSlices = Math.min(\n                Math.max(3, Math.floor(Math.random() * 5) + 3),\n                parameters.maxSlices || 7\n            );\n            console.log('Random behavior: using', numSlices, 'slices');\n        } else if (sliceBehavior === 'single-image') {\n            // For single image, use 5-50 slices\n            numSlices = Math.min(\n                Math.max(5, Math.floor(Math.random() * 46) + 5),\n                parameters.maxSlices || 50\n            );\n            console.log('Single image behavior: using', numSlices, 'slices');\n        } else {\n            // For alternating images, use 7-50 slices\n            numSlices = Math.min(\n                Math.max(7, Math.floor(Math.random() * 44) + 7),\n                parameters.maxSlices || 50\n            );\n            console.log('Alternating behavior: using', numSlices, 'slices');\n        }\n        \n        // Calculate base strip dimensions\n        const baseStripWidth = this.canvas.width / numSlices;\n        const baseStripHeight = this.canvas.height;\n        \n        // Filter images based on scaling requirements\n        const filteredImages = [];\n        const MAX_ATTEMPTS = 5;\n        \n        for (const image of validImages) {\n            // Calculate required scale for this image\n            const requiredScale = this.calculateRequiredScale(\n                image,\n                baseStripWidth,\n                baseStripHeight\n            );\n            \n            // Check if this scale is within our acceptable range\n            const maxAllowedScale = 2.0; // Maximum allowed scale for sliced effect\n            if (requiredScale <= maxAllowedScale) {\n                filteredImages.push(image);\n            }\n        }\n        \n        if (filteredImages.length === 0) {\n            console.warn('No images found that meet scaling requirements, using all valid images');\n            // If no images meet the scaling requirements, use all valid images\n            filteredImages.push(...validImages);\n        }\n        \n        // Select images based on slice behavior\n        if (sliceBehavior === 'single-image' && filteredImages.length > 0) {\n            // Select a single image to use for all slices\n            selectedImage = filteredImages[Math.floor(Math.random() * filteredImages.length)];\n            console.log('Using single image for all slices:', selectedImage.src);\n        } else if (sliceBehavior === 'alternating' && filteredImages.length >= 2) {\n            // Select two images to alternate between\n            const randomIndex = Math.floor(Math.random() * filteredImages.length);\n            selectedImage = filteredImages[randomIndex];\n            secondImage = filteredImages[(randomIndex + 1) % filteredImages.length];\n            console.log('Using alternating images for slices:', selectedImage.src, secondImage.src);\n        } else {\n            console.log('Using random images for slices');\n        }\n        \n        // Create the sliced effect\n        const slices = this.createSlicedEffect(numSlices, filteredImages, selectedImage, secondImage, parameters);\n        \n        // Draw the slices\n        this.drawSlices(slices);\n        \n        return slices;\n    }\n    \n    // Create a sliced effect with evenly divided strips\n    createSlicedEffect(numberOfSlices, images, selectedImage, secondImage, parameters) {\n        const slices = [];\n        const baseStripWidth = this.canvas.width / numberOfSlices;\n        const baseStripHeight = this.canvas.height;\n        \n        // Calculate width variation\n        const variation = parameters.sliceWidthVariation || 0.1;\n        \n        // Create slices with minimal variation to ensure even distribution\n        let currentPosition = 0;\n        \n        // For random behavior, create a shuffled array of images to ensure uniqueness\n        let shuffledImages = [];\n        if (!selectedImage) {\n            // Create a copy of the images array and shuffle it\n            shuffledImages = [...images];\n            this.shuffleArray(shuffledImages);\n            \n            // If we have fewer images than slices, we'll need to reuse some\n            if (shuffledImages.length < numberOfSlices) {\n                // Fill the array with repeated images to match the number of slices\n                while (shuffledImages.length < numberOfSlices) {\n                    shuffledImages.push(...this.shuffleArray([...images]));\n                }\n            }\n        }\n        \n        for (let i = 0; i < numberOfSlices; i++) {\n            // Use larger variation for single-image slices to make them more distinct\n            const widthVariation = selectedImage && !secondImage ? 0.2 : 0.1;\n            const stripWidth = baseStripWidth * (1 + (Math.random() * widthVariation - widthVariation/2));\n            \n            // Determine which image to use for this slice\n            let imageToUse;\n            if (selectedImage) {\n                // For single-image or alternating behavior\n                if (secondImage && i % 2 === 1) {\n                    imageToUse = secondImage;\n                } else {\n                    imageToUse = selectedImage;\n                }\n            } else {\n                // For random behavior - use a unique image from the shuffled array\n                imageToUse = shuffledImages[i];\n            }\n            \n            // Create slice with proper image positioning\n            const slice = {\n                image: imageToUse,\n                x: currentPosition,\n                y: 0,\n                width: stripWidth,\n                height: baseStripHeight,\n                rotation: 0,\n                // Add slight opacity variation for single-image slices\n                opacity: selectedImage && !secondImage ? 0.85 + (Math.random() * 0.3) : 1.0,\n                // Add offset properties for single-image and alternating behaviors\n                imageOffsetX: selectedImage ? i / numberOfSlices : 0,\n                imageOffsetY: 0\n            };\n            \n            slices.push(slice);\n            currentPosition += stripWidth;\n        }\n        \n        // Ensure the last slice fills any remaining space\n        if (slices.length > 0) {\n            const lastSlice = slices[slices.length - 1];\n            lastSlice.width = this.canvas.width - lastSlice.x;\n        }\n        \n        return slices;\n    }\n    \n    // Draw the slices\n    drawSlices(slices) {\n        for (const slice of slices) {\n            this.drawSlice(slice);\n        }\n    }\n    \n    // Draw a single slice\n    drawSlice(slice) {\n        if (!slice.image || !slice.image.complete) return;\n        \n        // Save the current context state\n        this.ctx.save();\n        \n        // Set opacity\n        this.ctx.globalAlpha = slice.opacity || 1.0;\n        \n        // Calculate dimensions to maintain aspect ratio\n        const imgAspectRatio = slice.image.naturalWidth / slice.image.naturalHeight;\n        const sliceAspectRatio = slice.width / slice.height;\n        \n        let drawWidth, drawHeight;\n        let offsetX = 0, offsetY = 0;\n        \n        // Apply image offsets if they exist (for single-image and alternating behaviors)\n        if (slice.imageOffsetX !== undefined || slice.imageOffsetY !== undefined) {\n            if (imgAspectRatio > sliceAspectRatio) {\n                // Image is wider than slice\n                drawHeight = slice.height;\n                drawWidth = drawHeight * imgAspectRatio;\n                // Adjust offset calculation to ensure full image visibility\n                offsetX = (drawWidth - slice.width) * (slice.imageOffsetX || 0);\n            } else {\n                // Image is taller than slice\n                drawWidth = slice.width;\n                drawHeight = drawWidth / imgAspectRatio;\n                // Adjust offset calculation to ensure full image visibility\n                offsetY = (drawHeight - slice.height) * (slice.imageOffsetY || 0);\n            }\n        } else {\n            // No offsets, just fit the image to the slice\n            if (imgAspectRatio > sliceAspectRatio) {\n                drawHeight = slice.height;\n                drawWidth = drawHeight * imgAspectRatio;\n                offsetX = (drawWidth - slice.width) / 2;\n            } else {\n                drawWidth = slice.width;\n                drawHeight = drawWidth / imgAspectRatio;\n                offsetY = (drawHeight - slice.height) / 2;\n            }\n        }\n        \n        // Create clipping path for the slice\n        this.ctx.beginPath();\n        this.ctx.rect(slice.x, slice.y, slice.width, slice.height);\n        this.ctx.clip();\n        \n        // Draw the image with proper positioning\n        this.ctx.drawImage(\n            slice.image,\n            slice.x - offsetX,\n            slice.y - offsetY,\n            drawWidth,\n            drawHeight\n        );\n        \n        // Restore the context state\n        this.ctx.restore();\n    }\n    \n    // Helper function to shuffle an array\n    shuffleArray(array) {\n        const newArray = [...array];\n        for (let i = newArray.length - 1; i > 0; i--) {\n            const j = Math.floor(Math.random() * (i + 1));\n            [newArray[i], newArray[j]] = [newArray[j], newArray[i]];\n        }\n        return newArray;\n    }\n} "],
  "mappings": "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",
  "names": []
}
