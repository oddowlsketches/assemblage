import "./chunk-BUSYA2B4.js";

// src/legacy/js/collage/fragmentsGenerator.js
var FragmentsGenerator = class {
  constructor(ctx, canvas) {
    this.ctx = ctx;
    this.canvas = canvas;
    if (!this.canvas) {
      this.canvas = {
        width: 1200,
        height: 800
      };
    }
    if (!this.canvas.width || !this.canvas.height) {
      this.canvas.width = 1200;
      this.canvas.height = 800;
    }
  }
  generateBackgroundColor() {
    const colors = [
      "#FF6B6B",
      // Coral Red
      "#4ECDC4",
      // Turquoise
      "#45B7D1",
      // Sky Blue
      "#96CEB4",
      // Sage Green
      "#FFEEAD",
      // Cream
      "#D4A5A5",
      // Dusty Rose
      "#9B59B6",
      // Purple
      "#3498DB",
      // Blue
      "#E67E22",
      // Orange
      "#2ECC71"
      // Green
    ];
    return colors[Math.floor(Math.random() * colors.length)];
  }
  calculateRequiredScale(image, targetWidth, targetHeight, minVisibility = 0.7) {
    const imgRatio = image.naturalWidth / image.naturalHeight;
    const targetRatio = targetWidth / targetHeight;
    let scale;
    if (imgRatio > targetRatio) {
      scale = targetHeight / image.naturalHeight;
    } else {
      scale = targetWidth / image.naturalWidth;
    }
    const minScale = Math.max(
      minVisibility / imgRatio,
      minVisibility * imgRatio
    );
    return Math.max(scale, minScale);
  }
  async generateFragments(images, fortuneText, parameters = {}) {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.fillStyle = this.generateBackgroundColor();
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    const validImages = [];
    const MAX_ATTEMPTS = 5;
    for (const image of images) {
      if (!image || !image.complete || image.naturalWidth === 0) continue;
      let fragmentWidth, fragmentHeight;
      if (parameters.variation === "Organic") {
        const size = this.calculateOrganicSize(this.canvas.width, this.canvas.height);
        fragmentWidth = size.width;
        fragmentHeight = size.height;
      } else if (parameters.variation === "Focal") {
        const size = this.calculateFocalSize(this.canvas.width, this.canvas.height, this.canvas.width / 2, this.canvas.height / 2);
        fragmentWidth = size.width;
        fragmentHeight = size.height;
      } else {
        const size = this.calculateClassicSize(this.canvas.width, this.canvas.height);
        fragmentWidth = size.width;
        fragmentHeight = size.height;
      }
      const requiredScale = this.calculateRequiredScale(
        image,
        fragmentWidth,
        fragmentHeight
      );
      const maxAllowedScale = parameters.variation === "Focal" ? 2.5 : 2;
      if (requiredScale <= maxAllowedScale) {
        validImages.push(image);
      }
    }
    if (validImages.length === 0) {
      console.warn("No valid images found that meet scaling requirements");
      return;
    }
    const complexityVariation = 0.75 + Math.random() * 0.3;
    const numFragments = Math.min(
      Math.max(3, Math.floor(validImages.length * parameters.complexity * 0.7 * complexityVariation)),
      parameters.maxFragments || 8
    );
    const fragments = [];
    const margin = 0;
    for (let i = 0; i < numFragments; i++) {
      let fragmentWidth, fragmentHeight;
      if (parameters.variation === "Organic") {
        const size = this.calculateOrganicSize(this.canvas.width, this.canvas.height);
        fragmentWidth = size.width;
        fragmentHeight = size.height;
      } else if (parameters.variation === "Focal") {
        const size = this.calculateFocalSize(this.canvas.width, this.canvas.height, this.canvas.width / 2, this.canvas.height / 2);
        fragmentWidth = size.width;
        fragmentHeight = size.height;
      } else {
        const size = this.calculateClassicSize(this.canvas.width, this.canvas.height);
        fragmentWidth = size.width;
        fragmentHeight = size.height;
      }
      const maxX = this.canvas.width - fragmentWidth;
      const maxY = this.canvas.height - fragmentHeight;
      const x = margin + Math.random() * (maxX - 2 * margin);
      const y = margin + Math.random() * (maxY - 2 * margin);
      const fragment = {
        image: validImages[i % validImages.length],
        x,
        y,
        width: fragmentWidth,
        height: fragmentHeight,
        rotation: Math.random() < 0.7 ? 0 : Math.random() * 0.2,
        depth: Math.random(),
        mask: {
          enabled: Math.random() < 0.3,
          type: ["circle", "triangle", "rectangle", "ellipse", "diamond", "hexagon", "arc", "arch", "circle", "triangle", "rectangle"][Math.floor(Math.random() * 11)]
        }
      };
      fragments.push(fragment);
    }
    fragments.sort((a, b) => a.depth - b.depth);
    return fragments;
  }
  generateFragmentsByVariation(fragments, count, sizeTiers, variation, images, imageIndices, allowImageRepetition) {
    const centerX = this.canvas.width / 2;
    const centerY = this.canvas.height / 2;
    let currentIndex = 0;
    for (let i = 0; i < count; i++) {
      const positionBias = Math.random() < 0.3 ? 0.05 : 0;
      let x = (Math.random() * (1 - 2 * positionBias) + positionBias) * this.canvas.width;
      let y = (Math.random() * (1 - 2 * positionBias) + positionBias) * this.canvas.height;
      const centerBias = 0.05;
      x = x * (1 - centerBias) + centerX * centerBias;
      y = y * (1 - centerBias) + centerY * centerBias;
      let rotation = 0;
      if (Math.random() >= 0.75) {
        const rotationAmount = Math.random() * 0.15;
        rotation = (Math.random() < 0.5 ? -1 : 1) * rotationAmount;
      }
      let baseSize;
      if (variation === "Organic") {
        baseSize = this.calculateOrganicSize(this.canvas.width, this.canvas.height);
      } else if (variation === "Focal") {
        baseSize = this.calculateFocalSize(this.canvas.width, this.canvas.height, x, y);
      } else {
        baseSize = this.calculateClassicSize(this.canvas.width, this.canvas.height);
      }
      const aspectVariation = Math.random() * 0.6 + 0.7;
      const width = baseSize.width;
      const height = baseSize.height;
      const overflowAllowed = Math.random() < 0.4 ? 0.95 : 0.75;
      const minDistance = Math.max(width, height) * 1.1;
      let attempts = 0;
      let validPosition = false;
      while (!validPosition && attempts < 20) {
        x = Math.max(-width * overflowAllowed, Math.min(x, this.canvas.width - width * (1 - overflowAllowed)));
        y = Math.max(-height * overflowAllowed, Math.min(y, this.canvas.height - height * (1 - overflowAllowed)));
        validPosition = true;
        let overlappingCount = 0;
        for (const existingFragment of fragments) {
          const dx = x - existingFragment.x;
          const dy = y - existingFragment.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const sizeRatio = Math.max(
            width / existingFragment.width,
            existingFragment.width / width
          );
          const overlapFactor = sizeRatio > 2.5 ? 0.4 : 0.9;
          const minRequiredDistance = (width + existingFragment.width) * overlapFactor;
          if (distance < minRequiredDistance) {
            overlappingCount++;
            if (overlappingCount >= 1) {
              validPosition = false;
              const moveDirection = { x: dx || 0.1, y: dy || 0.1 };
              const moveDistance = minDistance * 1.8;
              const magnitude = Math.sqrt(moveDirection.x * moveDirection.x + moveDirection.y * moveDirection.y);
              x += moveDirection.x / magnitude * moveDistance * (0.8 + Math.random() * 0.4);
              y += moveDirection.y / magnitude * moveDistance * (0.8 + Math.random() * 0.4);
              break;
            }
          }
        }
        attempts++;
      }
      console.log(`Fragment ${i} position:`, {
        x,
        y,
        width,
        height,
        overflowAllowed,
        attempts,
        validPosition,
        canvasBounds: {
          minX: -width * overflowAllowed,
          maxX: this.canvas.width - width * (1 - overflowAllowed),
          minY: -height * overflowAllowed,
          maxY: this.canvas.height - height * (1 - overflowAllowed)
        }
      });
      let imgIndex;
      if (allowImageRepetition) {
        imgIndex = Math.floor(Math.random() * images.length);
      } else {
        imgIndex = imageIndices[currentIndex % imageIndices.length];
        currentIndex++;
      }
      fragments.push({
        img: imgIndex,
        x,
        y,
        width,
        height,
        rotation,
        depth: Math.random()
      });
    }
  }
  calculateOrganicSize(width, height) {
    const sizeCategory = Math.random();
    let baseSize;
    if (sizeCategory < 0.35) {
      baseSize = 0.15 + Math.random() * 0.1;
    } else if (sizeCategory < 0.85) {
      baseSize = 0.2 + Math.random() * 0.05;
    } else if (sizeCategory < 0.95) {
      baseSize = 0.35 + Math.random() * 0.15;
    } else {
      baseSize = 0.2 + Math.random() * 0.05;
    }
    const widthVariation = 0.5 + Math.random() * 0.5;
    const heightVariation = 0.5 + Math.random() * 0.5;
    return {
      width: width * baseSize * widthVariation,
      height: height * baseSize * heightVariation
    };
  }
  calculateFocalSize(width, height, x, y) {
    const centerX = 0.5;
    const centerY = 0.5;
    const distanceFromCenter = Math.sqrt(
      Math.pow(x / width - centerX, 2) + Math.pow(y / height - centerY, 2)
    );
    const sizeCategory = Math.random();
    let baseSize;
    if (distanceFromCenter < 0.3) {
      if (sizeCategory < 0.6) {
        baseSize = 0.2 + (1 - distanceFromCenter) * 0.05;
      } else if (sizeCategory < 0.9) {
        baseSize = 0.35 + (1 - distanceFromCenter) * 0.15;
      } else {
        baseSize = 0.2 + (1 - distanceFromCenter) * 0.05;
      }
    } else {
      if (sizeCategory < 0.7) {
        baseSize = 0.15 + (1 - distanceFromCenter) * 0.1;
      } else {
        baseSize = 0.2 + (1 - distanceFromCenter) * 0.05;
      }
    }
    const variation = 0.6 + Math.random() * 0.4;
    return {
      width: width * baseSize * variation,
      height: height * baseSize * variation
    };
  }
  calculateClassicSize(width, height) {
    const sizeCategory = Math.random();
    let baseSize;
    if (sizeCategory < 0.3) {
      baseSize = 0.15 + Math.random() * 0.1;
    } else if (sizeCategory < 0.8) {
      baseSize = 0.2 + Math.random() * 0.05;
    } else if (sizeCategory < 0.9) {
      baseSize = 0.35 + Math.random() * 0.15;
    } else {
      baseSize = 0.2 + Math.random() * 0.05;
    }
    const variation = 0.6 + Math.random() * 0.4;
    return {
      width: width * baseSize * variation,
      height: height * baseSize * variation
    };
  }
  postProcessFragments(fragments, variation) {
    const layerCount = 5;
    fragments.forEach((fragment) => {
      const layerIndex = Math.floor(fragment.depth * layerCount);
      fragment.depth = (layerIndex + Math.random() * 0.8) / layerCount;
      if (Math.random() < 0.75) {
        fragment.rotation = (Math.random() < 0.5 ? -1 : 1) * (Math.random() * 0.12);
      } else {
        fragment.rotation = 0;
      }
    });
    if (fragments.length > 0) {
      let maxDepthFragment = fragments[0];
      fragments.forEach((fragment) => {
        if (fragment.depth > maxDepthFragment.depth) {
          maxDepthFragment = fragment;
        }
      });
      maxDepthFragment.forceFullOpacity = true;
      if (Math.random() < 0.7) {
        maxDepthFragment.rotation = 0;
      }
    }
    fragments.sort((a, b) => a.depth - b.depth);
    if (variation === "Focal") {
      const fragmentsCopy = [...fragments];
      fragmentsCopy.sort((a, b) => b.width * b.height - a.width * a.height);
      const largeFragmentThreshold = fragmentsCopy[Math.floor(fragments.length * 0.3)].width * fragmentsCopy[Math.floor(fragments.length * 0.3)].height;
      fragments.forEach((fragment) => {
        if (fragment.width * fragment.height >= largeFragmentThreshold && Math.random() < 0.8) {
          fragment.depth = 0.7 + Math.random() * 0.3;
          if (Math.random() < 0.7) {
            fragment.rotation = (Math.random() < 0.5 ? -1 : 1) * (Math.random() * 0.05);
          } else {
            fragment.rotation = (Math.random() < 0.5 ? -1 : 1) * (Math.random() * 0.1);
          }
        }
      });
      fragments.sort((a, b) => a.depth - b.depth);
    }
  }
  shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
  }
  drawFragment(fragment, ctx) {
    console.log("Drawing fragment:", fragment);
    const { x, y, width, height, image, rotation, mask } = fragment;
    if (!image || typeof image === "undefined") {
      console.warn("Invalid image for fragment:", fragment);
      return;
    }
    if (isNaN(x) || isNaN(y) || isNaN(width) || isNaN(height)) {
      console.warn("Invalid fragment dimensions or position:", { x, y, width, height });
      return;
    }
    const canvasArea = this.canvas.width * this.canvas.height;
    const fragmentArea = width * height;
    const fragmentSizeRatio = fragmentArea / canvasArea;
    const drawScale = 1 + Math.max(0, 0.3 - fragmentSizeRatio * 20);
    const effectiveRotation = Math.abs(rotation) < 0.01 ? 0 : rotation;
    ctx.save();
    ctx.translate(x + width / 2, y + height / 2);
    ctx.rotate(effectiveRotation);
    ctx.scale(drawScale, drawScale);
    if (mask && mask.enabled) {
      this.applyMask(ctx, mask.type, width, height);
      ctx.clip();
    }
    ctx.drawImage(image, -width / 2, -height / 2, width, height);
    ctx.restore();
    console.log("Fragment drawn at position:", x, y, "with dimensions:", width, height, "scale:", drawScale);
  }
  applyMask(ctx, maskType, width, height) {
    const centerX = 0;
    const centerY = 0;
    const size = Math.min(width, height) * 0.9;
    ctx.beginPath();
    switch (maskType) {
      case "circle":
        ctx.arc(centerX, centerY, size / 2, 0, Math.PI * 2);
        break;
      case "triangle":
        ctx.moveTo(centerX, centerY - size / 2);
        ctx.lineTo(centerX + size / 2, centerY + size / 2);
        ctx.lineTo(centerX - size / 2, centerY + size / 2);
        break;
      case "rectangle":
        ctx.rect(centerX - size / 2, centerY - size / 2, size, size);
        break;
      case "ellipse":
        ctx.ellipse(centerX, centerY, size / 2, size / 3, 0, 0, Math.PI * 2);
        break;
      case "diamond":
        ctx.moveTo(centerX, centerY - size / 2);
        ctx.lineTo(centerX + size / 2, centerY);
        ctx.lineTo(centerX, centerY + size / 2);
        ctx.lineTo(centerX - size / 2, centerY);
        break;
      case "hexagon":
        const hexAngle = Math.PI * 2 / 6;
        for (let i = 0; i < 6; i++) {
          const x = centerX + size / 2 * Math.cos(hexAngle * i);
          const y = centerY + size / 2 * Math.sin(hexAngle * i);
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        break;
      case "arc":
        ctx.arc(centerX, centerY, size / 2, 0, Math.PI * 2);
        break;
      case "arch":
        ctx.arc(centerX, centerY, size / 2, Math.PI * 0.2, Math.PI * 1.8);
        break;
      default:
        ctx.rect(centerX - size / 2, centerY - size / 2, size, size);
        break;
    }
    ctx.closePath();
  }
};
export {
  FragmentsGenerator
};
//# sourceMappingURL=___src_legacy_js_collage_fragmentsGenerator__js.js.map
