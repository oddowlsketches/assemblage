{
  "version": 3,
  "sources": ["../../../src/legacy/js/collage/tilingGenerator.js"],
  "sourcesContent": ["/**\n * Improved Tiling Generator for Assemblage\n * Combines the working tiling functionality with the advanced features\n */\n\nexport class TilingGenerator {\n    constructor(canvas, parameters) {\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d');\n        this.parameters = parameters;\n        this.ABSOLUTE_MAX_REPEATS = 3; // Maximum number of times an image can be repeated\n        this.imageUsageCount = new Map(); // Track how many times each image is used\n    }\n\n    calculateRequiredScale(image, targetWidth, targetHeight, minVisibility = 0.7) {\n        const imgRatio = image.naturalWidth / image.naturalHeight;\n        const targetRatio = targetWidth / targetHeight;\n        \n        let scale;\n        if (imgRatio > targetRatio) {\n            // Image is wider than target\n            scale = targetHeight / image.naturalHeight;\n        } else {\n            // Image is taller than target\n            scale = targetWidth / image.naturalWidth;\n        }\n        \n        // Account for minimum visibility requirement\n        const minScale = Math.max(\n            minVisibility / imgRatio,\n            minVisibility * imgRatio\n        );\n        \n        return Math.max(scale, minScale);\n    }\n\n    // Helper function to shuffle arrays (used in multiple effects)\n    shuffleArray(array) {\n        for (let i = array.length - 1; i > 0; i--) {\n            const j = Math.floor(Math.random() * (i + 1));\n            [array[i], array[j]] = [array[j], array[i]];\n        }\n        return array;\n    }\n\n    // Helper function to preserve aspect ratio when drawing tiles\n    preserveAspectRatio(image, x, y, targetWidth, targetHeight) {\n        if (!image || !image.complete) return false;\n        \n        const imgRatio = image.width / image.height;\n        const targetRatio = targetWidth / targetHeight;\n        \n        let drawWidth, drawHeight, drawX, drawY;\n        \n        if (imgRatio > targetRatio) {\n            // Image is wider - match width and center vertically\n            drawWidth = targetWidth;\n            drawHeight = drawWidth / imgRatio;\n            drawX = x;\n            drawY = y + (targetHeight - drawHeight) / 2;\n        } else {\n            // Image is taller - match height and center horizontally\n            drawHeight = targetHeight;\n            drawWidth = drawHeight * imgRatio;\n            drawX = x + (targetWidth - drawWidth) / 2;\n            drawY = y;\n        }\n        \n        // Draw with proper dimensions\n        this.ctx.drawImage(\n            image,\n            0, 0, image.width, image.height, // Source\n            drawX, drawY, drawWidth, drawHeight // Destination\n        );\n        \n        return true;\n    }\n\n    // Enhanced tile drawing with aspect ratio preservation\n    drawTileWithAspectRatio(image, x, y, width, height) {\n        // Skip missing or incomplete images\n        if (!image || !image.complete) return;\n        \n        // Save current context state\n        this.ctx.save();\n        \n        // Calculate aspect ratio\n        const imgAspectRatio = image.width / image.height;\n        let drawWidth, drawHeight, drawX, drawY;\n        \n        // Always preserve original aspect ratio\n        if (imgAspectRatio > 1) {\n            // Landscape image - match width\n            drawWidth = width;\n            drawHeight = width / imgAspectRatio;\n            drawX = x;\n            drawY = y + (height - drawHeight) / 2;\n        } else {\n            // Portrait image - match height\n            drawHeight = height;\n            drawWidth = height * imgAspectRatio;\n            drawX = x + (width - drawWidth) / 2;\n            drawY = y;\n        }\n        \n        // Draw with proper dimensions\n        this.ctx.drawImage(\n            image,\n            0, 0, image.width, image.height, // Source (full image)\n            drawX, drawY, drawWidth, drawHeight // Destination\n        );\n        \n        // Restore context\n        this.ctx.restore();\n    }\n\n    async generateTile(images, x, y, size, preferredImageIndex = null) {\n        // Validate inputs\n        if (!images || images.length === 0) {\n            console.warn('No images provided for tile generation');\n            return null;\n        }\n\n        // Determine if image repetition is allowed\n        const allowImageRepetition = this.parameters.allowImageRepetition !== null \n            ? this.parameters.allowImageRepetition \n            : true; // Default to true to ensure we can always find an image\n\n        // Track attempts to find a suitable image\n        const MAX_ATTEMPTS = 10; // Increased from 5 to 10\n        let attempts = 0;\n        let selectedImage = null;\n        let imageIndex = null;\n\n        while (!selectedImage && attempts < MAX_ATTEMPTS) {\n            // Select image index\n            if (preferredImageIndex !== null && attempts === 0) {\n                imageIndex = preferredImageIndex;\n            } else if (!allowImageRepetition) {\n                // No repetition - use each image only once\n                const unusedImages = Array.from({length: images.length}, (_, i) => i)\n                    .filter(idx => !(this.imageUsageCount.get(idx) || 0));\n                    \n                if (unusedImages.length === 0) {\n                    // If no unused images, fall back to allowing repetition\n                    imageIndex = Math.floor(Math.random() * images.length);\n                } else {\n                    imageIndex = unusedImages[Math.floor(Math.random() * unusedImages.length)];\n                }\n            } else {\n                // Allow repetition with limits\n                imageIndex = Math.floor(Math.random() * images.length);\n                const currentCount = this.imageUsageCount.get(imageIndex) || 0;\n                if (currentCount >= this.ABSOLUTE_MAX_REPEATS) {\n                    attempts++;\n                    continue;\n                }\n            }\n\n            const image = images[imageIndex];\n            \n            // Basic image validation\n            if (!image || !image.complete || image.naturalWidth === 0) {\n                attempts++;\n                continue;\n            }\n\n            // Calculate required scale for this image\n            const requiredScale = this.calculateRequiredScale(\n                image,\n                size,\n                size,\n                0.5 // Reduced minimum visibility requirement from 0.7 to 0.5\n            );\n\n            // Check if this scale is within our acceptable range\n            const maxAllowedScale = this.parameters.useDramaticScaling ? 4.0 : 3.0; // Increased from 3.0/2.5\n            if (requiredScale <= maxAllowedScale) {\n                selectedImage = image;\n            } else {\n                attempts++;\n            }\n        }\n\n        if (!selectedImage) {\n            console.warn(`Could not find suitable image after ${MAX_ATTEMPTS} attempts. Falling back to first valid image.`);\n            // Fallback: use the first valid image we can find\n            for (let i = 0; i < images.length; i++) {\n                const image = images[i];\n                if (image && image.complete && image.naturalWidth > 0) {\n                    selectedImage = image;\n                    imageIndex = i;\n                    break;\n                }\n            }\n            \n            if (!selectedImage) {\n                console.error('No valid images found in the provided set');\n                return null;\n            }\n        }\n\n        // Update usage count\n        const currentCount = this.imageUsageCount.get(imageIndex) || 0;\n        this.imageUsageCount.set(imageIndex, currentCount + 1);\n\n        // Calculate aspect-preserving dimensions\n        const imgRatio = selectedImage.naturalWidth / selectedImage.naturalHeight;\n        let finalWidth, finalHeight;\n        \n        if (imgRatio > 1) {\n            // Landscape image\n            finalWidth = size;\n            finalHeight = size / imgRatio;\n        } else {\n            // Portrait image\n            finalHeight = size;\n            finalWidth = size * imgRatio;\n        }\n\n        // Center the image in the tile\n        const xOffset = (size - finalWidth) / 2;\n        const yOffset = (size - finalHeight) / 2;\n\n        return {\n            image: selectedImage,\n            x: x + xOffset,\n            y: y + yOffset,\n            width: finalWidth,\n            height: finalHeight\n        };\n    }\n\n    async generateTiles(images) {\n        if (!images || images.length === 0) return [];\n        \n        // Reset image usage tracking at the start of each generation\n        this.imageUsageCount.clear();\n        \n        // Determine if image repetition is allowed based on parameters\n        const allowImageRepetition = this.parameters.allowImageRepetition !== null \n            ? this.parameters.allowImageRepetition \n            : false; // Default to no repetition\n        \n        console.log(`Image repetition ${allowImageRepetition ? 'enabled' : 'disabled'}`);\n        \n        const isFocalStyle = this.parameters.selectedCompositionStyle === 'Focal';\n        \n        // Enhanced mode selection with better crystal effect control\n        const useDramaticMode = Math.random() < 0.4; // Increased to 40% chance for dramatic scaling\n        const useFocalMode = isFocalStyle ? Math.random() < 0.8 : Math.random() < 0.4; // Increased focal mode probability\n        \n        // Log the selected mode combination\n        const modeDescription = useDramaticMode ? 'dramatic scaling' : 'uniform scaling';\n        console.log(`Generating tiles in ${useFocalMode ? 'focal' : 'field'} mode with ${modeDescription}`);\n        \n        const tiles = [];\n        \n        if (useFocalMode) {\n            // Focal mode: Few, larger images with enhanced crystal effects\n            await this.generateFocalTiles(images, tiles, allowImageRepetition, useDramaticMode);\n        } else {\n            // Field mode: Many smaller images with enhanced crystal effects\n            await this.generateFieldTiles(images, tiles, allowImageRepetition, useDramaticMode);\n        }\n\n        console.log(`Generated ${tiles.length} tiles`);\n        \n        // Clear the canvas and set background\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        this.ctx.fillStyle = this.generateBackgroundColor();\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        \n        // Draw all tiles\n        for (const tile of tiles) {\n            this.drawTile(tile);\n        }\n        \n        return tiles;\n    }\n\n    drawTile(tile) {\n        if (!tile || !tile.image) return;\n        \n        this.ctx.save();\n        \n        // Apply rotation if specified\n        if (tile.rotation) {\n            this.ctx.translate(tile.x + tile.width/2, tile.y + tile.height/2);\n            this.ctx.rotate(tile.rotation * Math.PI / 180);\n            this.ctx.translate(-(tile.x + tile.width/2), -(tile.y + tile.height/2));\n        }\n        \n        // Apply opacity if specified\n        if (tile.forceOpacity !== null) {\n            this.ctx.globalAlpha = tile.forceOpacity;\n        }\n        \n        // Draw the image\n        this.ctx.drawImage(\n            tile.image,\n            tile.x,\n            tile.y,\n            tile.width,\n            tile.height\n        );\n        \n        this.ctx.restore();\n    }\n\n    generateBackgroundColor() {\n        // Generate a subtle background color\n        const hue = Math.random() * 360;\n        const saturation = 10 + Math.random() * 20; // 10-30%\n        const lightness = 85 + Math.random() * 10; // 85-95%\n        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;\n    }\n\n    async generateFocalTiles(images, tiles, allowImageRepetition, useDramaticScaling) {\n        // Larger base size for focal tiles\n        const baseSize = Math.max(200, this.canvas.width / 3.5);\n        \n        // Enhanced scale ranges for crystal effects\n        let minScale, maxScale;\n        \n        if (useDramaticScaling) {\n            // Dramatic scaling - greater variation for crystal effect\n            minScale = 0.3; // Reduced from 0.4 for more dramatic small tiles\n            maxScale = 3.5; // Increased from 3.0 for more dramatic large tiles\n        } else {\n            // Uniform scaling - less variation\n            minScale = 0.6;\n            maxScale = 2.5;\n        }\n        \n        // Generate 3-7 focal points (more with dramatic scaling)\n        const minFocal = useDramaticScaling ? 4 : 3;\n        const maxFocal = useDramaticScaling ? 7 : 5;\n        const numFocal = minFocal + Math.floor(Math.random() * (maxFocal - minFocal + 1));\n        \n        console.log(`Generating ${numFocal} focal tiles with scale range: ${minScale}-${maxScale}`);\n        \n        // Prepare image selection\n        let imageSequence = [];\n        if (!allowImageRepetition) {\n            // Create a shuffled sequence of unique images\n            imageSequence = this.shuffleArray(Array.from({length: images.length}, (_, i) => i))\n                .slice(0, Math.min(numFocal, images.length));\n        }\n        \n        // Positioning strategy - more intentional with dramatic scaling\n        let positionStrategy;\n        if (useDramaticScaling) {\n            // Create a more curated layout for dramatic scaling\n            // Define important positions (rule of thirds, golden ratio points)\n            const w = this.canvas.width;\n            const h = this.canvas.height;\n            \n            positionStrategy = [\n                // Rule of thirds points\n                {x: w/3, y: h/3},\n                {x: 2*w/3, y: h/3},\n                {x: w/3, y: 2*h/3},\n                {x: 2*w/3, y: 2*h/3},\n                // Golden ratio points\n                {x: w * 0.382, y: h * 0.382},\n                {x: w * 0.618, y: h * 0.382},\n                {x: w * 0.382, y: h * 0.618},\n                {x: w * 0.618, y: h * 0.618},\n                // Center\n                {x: w/2, y: h/2}\n            ];\n            \n            // Shuffle the positions\n            this.shuffleArray(positionStrategy);\n        }\n        \n        // Process for creating tiles\n        for (let i = 0; i < numFocal; i++) {\n            // Determine position based on strategy\n            let x, y;\n            \n            if (useDramaticScaling && i < positionStrategy.length) {\n                // Use the strategic positions for dramatic scaling\n                const pos = positionStrategy[i];\n                // Add slight randomness to avoid perfectly aligned tiles\n                const jitter = baseSize * 0.1;\n                x = pos.x + (Math.random() - 0.5) * jitter;\n                y = pos.y + (Math.random() - 0.5) * jitter;\n            } else {\n                // Random position\n                x = Math.random() * (this.canvas.width - baseSize * minScale);\n                y = Math.random() * (this.canvas.height - baseSize * minScale);\n            }\n            \n            // Determine scale with weighted distribution based on dramatic setting\n            let scale;\n            if (useDramaticScaling) {\n                // In dramatic mode, bias toward extremes (very large or small)\n                const rand = Math.random();\n                if (rand < 0.4) {\n                    // 40% chance of large tile\n                    scale = maxScale - (Math.random() * 0.3); // 1.3-1.6\n                } else if (rand < 0.7) {\n                    // 30% chance of small tile\n                    scale = minScale + (Math.random() * 0.2); // 0.4-0.6\n                } else {\n                    // 30% chance of medium tile\n                    scale = 0.8 + (Math.random() * 0.4); // 0.8-1.2\n                }\n            } else {\n                // In uniform mode, use a more regular distribution\n                scale = minScale + Math.random() * (maxScale - minScale);\n            }\n            \n            // Determine rotation - more dramatic in dramatic mode\n            const maxRotation = useDramaticScaling ? 45 : 20;\n            const rotation = Math.random() < 0.7 ? (Math.random() - 0.5) * maxRotation : 0;\n            \n            // Determine preferred image index if not allowing repetition\n            const preferredIndex = !allowImageRepetition ? imageSequence[i % imageSequence.length] : null;\n            \n            // Generate the tile with these specifications\n            const tile = await this.generateTile(\n                images, \n                x - (baseSize * scale / 2), // Center the tile at the determined position\n                y - (baseSize * scale / 2), \n                baseSize * scale,\n                preferredIndex\n            );\n            \n            if (tile) {\n                // Apply the rotation\n                tile.rotation = rotation;\n                \n                // Set opacity based on settings\n                tile.forceOpacity = useDramaticScaling ? \n                    (Math.random() < 0.3 ? 1.0 : 0.5 + Math.random() * 0.4) : // More full opacity tiles in dramatic mode\n                    (0.5 + Math.random() * 0.3); // Standard range\n                \n                tiles.push(tile);\n            }\n        }\n    }\n\n    async generateFieldTiles(images, tiles, allowImageRepetition, useDramaticScaling) {\n        if (!images || images.length === 0) return;\n        \n        const dpr = window.devicePixelRatio || 1;\n        \n        // Enhanced tile count variation for crystal effects\n        const minTiles = useDramaticScaling ? 20 : 40; // Reduced minimum for dramatic mode\n        const maxTiles = useDramaticScaling ? 80 : 120; // Increased maximum for dramatic mode\n        const targetTileCount = minTiles + Math.floor(Math.random() * (maxTiles - minTiles + 1));\n        \n        // Enhanced base size calculation for crystal effects\n        const baseSizeMultiplier = useDramaticScaling ? 3.5 : 6; // Reduced from 4 to allow for even larger tiles\n        const baseSize = Math.min(\n            this.canvas.width / (baseSizeMultiplier * dpr),\n            this.canvas.height / (5 * dpr)\n        );\n        \n        // Enhanced scale ranges for crystal effects\n        let minScale, maxScale;\n        \n        if (useDramaticScaling) {\n            // Dramatic scaling - greater variation\n            minScale = 0.6; // Reduced from 0.7 for more dramatic small tiles\n            maxScale = 3.5; // Increased from 3.0 for more dramatic large tiles\n        } else {\n            // Uniform scaling - less variation\n            minScale = 0.9;\n            maxScale = 2.5;\n        }\n        \n        // Calculate grid parameters for cell-based positioning\n        const overlapFactor = useDramaticScaling ? 0.75 : 0.65; // More overlap in dramatic mode\n        const numCols = Math.floor(this.canvas.width / (baseSize * overlapFactor * dpr)) + 1;\n        const numRows = Math.floor(this.canvas.height / (baseSize * overlapFactor * dpr)) + 1;\n        \n        // Calculate target number of tiles (but never more than available spaces)\n        const maxGridTiles = numCols * numRows;\n        const finalTargetTiles = Math.min(targetTileCount, maxGridTiles);\n        \n        console.log(`Generating field with ${finalTargetTiles} tiles (${numCols}x${numRows} grid)`);\n        console.log(`Base size: ${baseSize}, Scale: ${minScale}-${maxScale}`);\n        \n        // Calculate cell dimensions for positioning\n        const effectiveWidth = this.canvas.width / dpr;\n        const effectiveHeight = this.canvas.height / dpr;\n        const cellWidth = effectiveWidth / (numCols - 1);\n        const cellHeight = effectiveHeight / (numRows - 1);\n        \n        // Generate all possible positions based on the grid\n        const positions = [];\n        for (let row = -1; row < numRows + 1; row++) {\n            for (let col = -1; col < numCols + 1; col++) {\n                // Calculate base position\n                const baseX = col * cellWidth;\n                const baseY = row * cellHeight;\n                \n                // Add randomness based on scaling mode\n                const jitterRange = useDramaticScaling ? \n                    Math.min(cellWidth, cellHeight) * 0.25 : // More randomness in dramatic mode\n                    Math.min(cellWidth, cellHeight) * 0.15;\n                    \n                const x = baseX + (Math.random() - 0.5) * jitterRange;\n                const y = baseY + (Math.random() - 0.5) * jitterRange;\n                \n                positions.push({x, y});\n            }\n        }\n        \n        // Shuffle and limit positions\n        this.shuffleArray(positions);\n        positions.length = Math.min(positions.length, finalTargetTiles);\n        \n        // Determine rotation settings\n        const useRotations = Math.random() < (useDramaticScaling ? 0.9 : 0.7); // Higher chance in dramatic mode\n        const maxRotation = useDramaticScaling ? 45 : 25; // More extreme rotations in dramatic mode\n        \n        // Prepare image selection (only matters for non-repetition mode)\n        let currentImageIndex = 0;\n        const uniqueImageIndices = this.shuffleArray(Array.from({length: images.length}, (_, i) => i));\n        \n        // Generate opacity distribution with proper variation\n        const opacityDistribution = {\n            // Percentage of tiles with full opacity (1.0)\n            fullOpacity: useDramaticScaling ? 0.2 : 0.15,\n            // Percentage of tiles with high opacity (0.7-0.9)\n            highOpacity: useDramaticScaling ? 0.5 : 0.35,\n            // Remaining tiles get medium opacity (0.3-0.6)\n        };\n        \n        // Generate tiles\n        let generatedTiles = 0;\n        for (let i = 0; i < positions.length; i++) {\n            // Stop when we've reached the target number\n            if (generatedTiles >= finalTargetTiles) break;\n            \n            const pos = positions[i];\n            \n            // Determine preferred image index for non-repetition mode\n            let preferredIndex = null;\n            if (!allowImageRepetition) {\n                // Use the next unique image\n                if (currentImageIndex >= uniqueImageIndices.length) {\n                    // We've used all unique images, can't add more\n                    if (generatedTiles < minTiles) {\n                        console.warn(`Ran out of unique images after ${generatedTiles} tiles (min: ${minTiles})`);\n                    }\n                    break;\n                }\n                preferredIndex = uniqueImageIndices[currentImageIndex++];\n            }\n            \n            // Calculate scale with distribution based on mode\n            let scale;\n            if (useDramaticScaling) {\n                // In dramatic mode, create more variance\n                const rand = Math.random();\n                if (rand < 0.3) {\n                    // 30% chance for large tiles\n                    scale = maxScale - Math.random() * 0.3; // 1.5-1.8\n                } else if (rand < 0.6) {\n                    // 30% chance for small tiles\n                    scale = minScale + Math.random() * 0.2; // 0.7-0.9\n                } else {\n                    // 40% chance for medium tiles\n                    scale = 1.0 + Math.random() * 0.3; // 1.0-1.3\n                }\n            } else {\n                // Regular scale distribution\n                scale = minScale + Math.random() * (maxScale - minScale);\n            }\n            \n            // Calculate final size with proper scaling\n            const finalSize = baseSize * scale;\n            \n            // Determine rotation\n            const shouldRotate = useRotations && Math.random() < (useDramaticScaling ? 0.5 : 0.3);\n            const rotation = shouldRotate ? (Math.random() - 0.5) * maxRotation : 0;\n            \n            // Generate the tile\n            const tile = await this.generateTile(\n                images,\n                (pos.x - finalSize/2) * dpr,\n                (pos.y - finalSize/2) * dpr,\n                finalSize * dpr,\n                preferredIndex\n            );\n            \n            if (tile) {\n                // Apply rotation\n                tile.rotation = rotation;\n                \n                // Determine opacity based on distribution\n                const opacityRand = Math.random();\n                if (opacityRand < opacityDistribution.fullOpacity) {\n                    tile.forceOpacity = 1.0; // Full opacity\n                } else if (opacityRand < (opacityDistribution.fullOpacity + opacityDistribution.highOpacity)) {\n                    tile.forceOpacity = 0.7 + Math.random() * 0.3; // High opacity (0.7-1.0)\n                } else {\n                    tile.forceOpacity = 0.3 + Math.random() * 0.4; // Medium opacity (0.3-0.7)\n                }\n                \n                tiles.push(tile);\n                generatedTiles++;\n            }\n        }\n        \n        // Log statistics\n        console.log(`Generated ${tiles.length} field tiles (target: ${finalTargetTiles})`);\n        \n        // Image usage stats\n        const imageStats = {\n            uniqueImagesUsed: new Set([...this.imageUsageCount.entries()]\n                .filter(([_, count]) => count > 0)\n                .map(([idx, _]) => idx)).size,\n            maxUsageCount: Math.max(...[...this.imageUsageCount.values(), 0]),\n            rotationsEnabled: useRotations,\n            maxRotation: maxRotation,\n            totalTiles: tiles.length\n        };\n        \n        console.log('Field tile generation stats:', imageStats);\n    }\n\n    createDramaticTile(baseSize, dramaticScale, isFocalStyle) {\n        const targetFocalPos = { x: this.canvas.width / 2, y: this.canvas.height / 2 };\n        const dramaticSize = baseSize * dramaticScale;\n        const offsetX = (Math.random() - 0.5) * dramaticSize * 0.3;\n        const offsetY = (Math.random() - 0.5) * dramaticSize * 0.3;\n        const dramaticX = targetFocalPos.x - dramaticSize / 2 + offsetX;\n        const dramaticY = targetFocalPos.y - dramaticSize / 2 + offsetY;\n\n        return {\n            x: dramaticX, y: dramaticY,\n            width: dramaticSize, height: dramaticSize,\n            scale: dramaticScale, isDramaticCandidate: true,\n            forceOpacity: 1.0\n        };\n    }\n\n    assignOpacity(tile, dramaticTileData) {\n        if (tile.isDramaticCandidate) return 1.0;\n        const rand = Math.random();\n        if (rand < 0.07) return 1.0;\n        if (rand < 0.30) return 0.5 + Math.random() * 0.3;\n        return null;\n    }\n}"],
  "mappings": "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",
  "names": ["currentCount"]
}
