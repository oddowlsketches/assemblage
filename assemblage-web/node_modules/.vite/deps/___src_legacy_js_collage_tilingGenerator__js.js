import "./chunk-BUSYA2B4.js";

// src/legacy/js/collage/tilingGenerator.js
var TilingGenerator = class {
  constructor(canvas, parameters) {
    this.canvas = canvas;
    this.ctx = canvas.getContext("2d");
    this.parameters = parameters;
    this.ABSOLUTE_MAX_REPEATS = 3;
    this.imageUsageCount = /* @__PURE__ */ new Map();
  }
  calculateRequiredScale(image, targetWidth, targetHeight, minVisibility = 0.7) {
    const imgRatio = image.naturalWidth / image.naturalHeight;
    const targetRatio = targetWidth / targetHeight;
    let scale;
    if (imgRatio > targetRatio) {
      scale = targetHeight / image.naturalHeight;
    } else {
      scale = targetWidth / image.naturalWidth;
    }
    const minScale = Math.max(
      minVisibility / imgRatio,
      minVisibility * imgRatio
    );
    return Math.max(scale, minScale);
  }
  // Helper function to shuffle arrays (used in multiple effects)
  shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }
  // Helper function to preserve aspect ratio when drawing tiles
  preserveAspectRatio(image, x, y, targetWidth, targetHeight) {
    if (!image || !image.complete) return false;
    const imgRatio = image.width / image.height;
    const targetRatio = targetWidth / targetHeight;
    let drawWidth, drawHeight, drawX, drawY;
    if (imgRatio > targetRatio) {
      drawWidth = targetWidth;
      drawHeight = drawWidth / imgRatio;
      drawX = x;
      drawY = y + (targetHeight - drawHeight) / 2;
    } else {
      drawHeight = targetHeight;
      drawWidth = drawHeight * imgRatio;
      drawX = x + (targetWidth - drawWidth) / 2;
      drawY = y;
    }
    this.ctx.drawImage(
      image,
      0,
      0,
      image.width,
      image.height,
      // Source
      drawX,
      drawY,
      drawWidth,
      drawHeight
      // Destination
    );
    return true;
  }
  // Enhanced tile drawing with aspect ratio preservation
  drawTileWithAspectRatio(image, x, y, width, height) {
    if (!image || !image.complete) return;
    this.ctx.save();
    const imgAspectRatio = image.width / image.height;
    let drawWidth, drawHeight, drawX, drawY;
    if (imgAspectRatio > 1) {
      drawWidth = width;
      drawHeight = width / imgAspectRatio;
      drawX = x;
      drawY = y + (height - drawHeight) / 2;
    } else {
      drawHeight = height;
      drawWidth = height * imgAspectRatio;
      drawX = x + (width - drawWidth) / 2;
      drawY = y;
    }
    this.ctx.drawImage(
      image,
      0,
      0,
      image.width,
      image.height,
      // Source (full image)
      drawX,
      drawY,
      drawWidth,
      drawHeight
      // Destination
    );
    this.ctx.restore();
  }
  async generateTile(images, x, y, size, preferredImageIndex = null) {
    if (!images || images.length === 0) {
      console.warn("No images provided for tile generation");
      return null;
    }
    const allowImageRepetition = this.parameters.allowImageRepetition !== null ? this.parameters.allowImageRepetition : true;
    const MAX_ATTEMPTS = 10;
    let attempts = 0;
    let selectedImage = null;
    let imageIndex = null;
    while (!selectedImage && attempts < MAX_ATTEMPTS) {
      if (preferredImageIndex !== null && attempts === 0) {
        imageIndex = preferredImageIndex;
      } else if (!allowImageRepetition) {
        const unusedImages = Array.from({ length: images.length }, (_, i) => i).filter((idx) => !(this.imageUsageCount.get(idx) || 0));
        if (unusedImages.length === 0) {
          imageIndex = Math.floor(Math.random() * images.length);
        } else {
          imageIndex = unusedImages[Math.floor(Math.random() * unusedImages.length)];
        }
      } else {
        imageIndex = Math.floor(Math.random() * images.length);
        const currentCount2 = this.imageUsageCount.get(imageIndex) || 0;
        if (currentCount2 >= this.ABSOLUTE_MAX_REPEATS) {
          attempts++;
          continue;
        }
      }
      const image = images[imageIndex];
      if (!image || !image.complete || image.naturalWidth === 0) {
        attempts++;
        continue;
      }
      const requiredScale = this.calculateRequiredScale(
        image,
        size,
        size,
        0.5
        // Reduced minimum visibility requirement from 0.7 to 0.5
      );
      const maxAllowedScale = this.parameters.useDramaticScaling ? 4 : 3;
      if (requiredScale <= maxAllowedScale) {
        selectedImage = image;
      } else {
        attempts++;
      }
    }
    if (!selectedImage) {
      console.warn(`Could not find suitable image after ${MAX_ATTEMPTS} attempts. Falling back to first valid image.`);
      for (let i = 0; i < images.length; i++) {
        const image = images[i];
        if (image && image.complete && image.naturalWidth > 0) {
          selectedImage = image;
          imageIndex = i;
          break;
        }
      }
      if (!selectedImage) {
        console.error("No valid images found in the provided set");
        return null;
      }
    }
    const currentCount = this.imageUsageCount.get(imageIndex) || 0;
    this.imageUsageCount.set(imageIndex, currentCount + 1);
    const imgRatio = selectedImage.naturalWidth / selectedImage.naturalHeight;
    let finalWidth, finalHeight;
    if (imgRatio > 1) {
      finalWidth = size;
      finalHeight = size / imgRatio;
    } else {
      finalHeight = size;
      finalWidth = size * imgRatio;
    }
    const xOffset = (size - finalWidth) / 2;
    const yOffset = (size - finalHeight) / 2;
    return {
      image: selectedImage,
      x: x + xOffset,
      y: y + yOffset,
      width: finalWidth,
      height: finalHeight
    };
  }
  async generateTiles(images) {
    if (!images || images.length === 0) return [];
    this.imageUsageCount.clear();
    const allowImageRepetition = this.parameters.allowImageRepetition !== null ? this.parameters.allowImageRepetition : false;
    console.log(`Image repetition ${allowImageRepetition ? "enabled" : "disabled"}`);
    const isFocalStyle = this.parameters.selectedCompositionStyle === "Focal";
    const useDramaticMode = Math.random() < 0.4;
    const useFocalMode = isFocalStyle ? Math.random() < 0.8 : Math.random() < 0.4;
    const modeDescription = useDramaticMode ? "dramatic scaling" : "uniform scaling";
    console.log(`Generating tiles in ${useFocalMode ? "focal" : "field"} mode with ${modeDescription}`);
    const tiles = [];
    if (useFocalMode) {
      await this.generateFocalTiles(images, tiles, allowImageRepetition, useDramaticMode);
    } else {
      await this.generateFieldTiles(images, tiles, allowImageRepetition, useDramaticMode);
    }
    console.log(`Generated ${tiles.length} tiles`);
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.fillStyle = this.generateBackgroundColor();
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    for (const tile of tiles) {
      this.drawTile(tile);
    }
    return tiles;
  }
  drawTile(tile) {
    if (!tile || !tile.image) return;
    this.ctx.save();
    if (tile.rotation) {
      this.ctx.translate(tile.x + tile.width / 2, tile.y + tile.height / 2);
      this.ctx.rotate(tile.rotation * Math.PI / 180);
      this.ctx.translate(-(tile.x + tile.width / 2), -(tile.y + tile.height / 2));
    }
    if (tile.forceOpacity !== null) {
      this.ctx.globalAlpha = tile.forceOpacity;
    }
    this.ctx.drawImage(
      tile.image,
      tile.x,
      tile.y,
      tile.width,
      tile.height
    );
    this.ctx.restore();
  }
  generateBackgroundColor() {
    const hue = Math.random() * 360;
    const saturation = 10 + Math.random() * 20;
    const lightness = 85 + Math.random() * 10;
    return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
  }
  async generateFocalTiles(images, tiles, allowImageRepetition, useDramaticScaling) {
    const baseSize = Math.max(200, this.canvas.width / 3.5);
    let minScale, maxScale;
    if (useDramaticScaling) {
      minScale = 0.3;
      maxScale = 3.5;
    } else {
      minScale = 0.6;
      maxScale = 2.5;
    }
    const minFocal = useDramaticScaling ? 4 : 3;
    const maxFocal = useDramaticScaling ? 7 : 5;
    const numFocal = minFocal + Math.floor(Math.random() * (maxFocal - minFocal + 1));
    console.log(`Generating ${numFocal} focal tiles with scale range: ${minScale}-${maxScale}`);
    let imageSequence = [];
    if (!allowImageRepetition) {
      imageSequence = this.shuffleArray(Array.from({ length: images.length }, (_, i) => i)).slice(0, Math.min(numFocal, images.length));
    }
    let positionStrategy;
    if (useDramaticScaling) {
      const w = this.canvas.width;
      const h = this.canvas.height;
      positionStrategy = [
        // Rule of thirds points
        { x: w / 3, y: h / 3 },
        { x: 2 * w / 3, y: h / 3 },
        { x: w / 3, y: 2 * h / 3 },
        { x: 2 * w / 3, y: 2 * h / 3 },
        // Golden ratio points
        { x: w * 0.382, y: h * 0.382 },
        { x: w * 0.618, y: h * 0.382 },
        { x: w * 0.382, y: h * 0.618 },
        { x: w * 0.618, y: h * 0.618 },
        // Center
        { x: w / 2, y: h / 2 }
      ];
      this.shuffleArray(positionStrategy);
    }
    for (let i = 0; i < numFocal; i++) {
      let x, y;
      if (useDramaticScaling && i < positionStrategy.length) {
        const pos = positionStrategy[i];
        const jitter = baseSize * 0.1;
        x = pos.x + (Math.random() - 0.5) * jitter;
        y = pos.y + (Math.random() - 0.5) * jitter;
      } else {
        x = Math.random() * (this.canvas.width - baseSize * minScale);
        y = Math.random() * (this.canvas.height - baseSize * minScale);
      }
      let scale;
      if (useDramaticScaling) {
        const rand = Math.random();
        if (rand < 0.4) {
          scale = maxScale - Math.random() * 0.3;
        } else if (rand < 0.7) {
          scale = minScale + Math.random() * 0.2;
        } else {
          scale = 0.8 + Math.random() * 0.4;
        }
      } else {
        scale = minScale + Math.random() * (maxScale - minScale);
      }
      const maxRotation = useDramaticScaling ? 45 : 20;
      const rotation = Math.random() < 0.7 ? (Math.random() - 0.5) * maxRotation : 0;
      const preferredIndex = !allowImageRepetition ? imageSequence[i % imageSequence.length] : null;
      const tile = await this.generateTile(
        images,
        x - baseSize * scale / 2,
        // Center the tile at the determined position
        y - baseSize * scale / 2,
        baseSize * scale,
        preferredIndex
      );
      if (tile) {
        tile.rotation = rotation;
        tile.forceOpacity = useDramaticScaling ? Math.random() < 0.3 ? 1 : 0.5 + Math.random() * 0.4 : (
          // More full opacity tiles in dramatic mode
          0.5 + Math.random() * 0.3
        );
        tiles.push(tile);
      }
    }
  }
  async generateFieldTiles(images, tiles, allowImageRepetition, useDramaticScaling) {
    if (!images || images.length === 0) return;
    const dpr = window.devicePixelRatio || 1;
    const minTiles = useDramaticScaling ? 20 : 40;
    const maxTiles = useDramaticScaling ? 80 : 120;
    const targetTileCount = minTiles + Math.floor(Math.random() * (maxTiles - minTiles + 1));
    const baseSizeMultiplier = useDramaticScaling ? 3.5 : 6;
    const baseSize = Math.min(
      this.canvas.width / (baseSizeMultiplier * dpr),
      this.canvas.height / (5 * dpr)
    );
    let minScale, maxScale;
    if (useDramaticScaling) {
      minScale = 0.6;
      maxScale = 3.5;
    } else {
      minScale = 0.9;
      maxScale = 2.5;
    }
    const overlapFactor = useDramaticScaling ? 0.75 : 0.65;
    const numCols = Math.floor(this.canvas.width / (baseSize * overlapFactor * dpr)) + 1;
    const numRows = Math.floor(this.canvas.height / (baseSize * overlapFactor * dpr)) + 1;
    const maxGridTiles = numCols * numRows;
    const finalTargetTiles = Math.min(targetTileCount, maxGridTiles);
    console.log(`Generating field with ${finalTargetTiles} tiles (${numCols}x${numRows} grid)`);
    console.log(`Base size: ${baseSize}, Scale: ${minScale}-${maxScale}`);
    const effectiveWidth = this.canvas.width / dpr;
    const effectiveHeight = this.canvas.height / dpr;
    const cellWidth = effectiveWidth / (numCols - 1);
    const cellHeight = effectiveHeight / (numRows - 1);
    const positions = [];
    for (let row = -1; row < numRows + 1; row++) {
      for (let col = -1; col < numCols + 1; col++) {
        const baseX = col * cellWidth;
        const baseY = row * cellHeight;
        const jitterRange = useDramaticScaling ? Math.min(cellWidth, cellHeight) * 0.25 : (
          // More randomness in dramatic mode
          Math.min(cellWidth, cellHeight) * 0.15
        );
        const x = baseX + (Math.random() - 0.5) * jitterRange;
        const y = baseY + (Math.random() - 0.5) * jitterRange;
        positions.push({ x, y });
      }
    }
    this.shuffleArray(positions);
    positions.length = Math.min(positions.length, finalTargetTiles);
    const useRotations = Math.random() < (useDramaticScaling ? 0.9 : 0.7);
    const maxRotation = useDramaticScaling ? 45 : 25;
    let currentImageIndex = 0;
    const uniqueImageIndices = this.shuffleArray(Array.from({ length: images.length }, (_, i) => i));
    const opacityDistribution = {
      // Percentage of tiles with full opacity (1.0)
      fullOpacity: useDramaticScaling ? 0.2 : 0.15,
      // Percentage of tiles with high opacity (0.7-0.9)
      highOpacity: useDramaticScaling ? 0.5 : 0.35
      // Remaining tiles get medium opacity (0.3-0.6)
    };
    let generatedTiles = 0;
    for (let i = 0; i < positions.length; i++) {
      if (generatedTiles >= finalTargetTiles) break;
      const pos = positions[i];
      let preferredIndex = null;
      if (!allowImageRepetition) {
        if (currentImageIndex >= uniqueImageIndices.length) {
          if (generatedTiles < minTiles) {
            console.warn(`Ran out of unique images after ${generatedTiles} tiles (min: ${minTiles})`);
          }
          break;
        }
        preferredIndex = uniqueImageIndices[currentImageIndex++];
      }
      let scale;
      if (useDramaticScaling) {
        const rand = Math.random();
        if (rand < 0.3) {
          scale = maxScale - Math.random() * 0.3;
        } else if (rand < 0.6) {
          scale = minScale + Math.random() * 0.2;
        } else {
          scale = 1 + Math.random() * 0.3;
        }
      } else {
        scale = minScale + Math.random() * (maxScale - minScale);
      }
      const finalSize = baseSize * scale;
      const shouldRotate = useRotations && Math.random() < (useDramaticScaling ? 0.5 : 0.3);
      const rotation = shouldRotate ? (Math.random() - 0.5) * maxRotation : 0;
      const tile = await this.generateTile(
        images,
        (pos.x - finalSize / 2) * dpr,
        (pos.y - finalSize / 2) * dpr,
        finalSize * dpr,
        preferredIndex
      );
      if (tile) {
        tile.rotation = rotation;
        const opacityRand = Math.random();
        if (opacityRand < opacityDistribution.fullOpacity) {
          tile.forceOpacity = 1;
        } else if (opacityRand < opacityDistribution.fullOpacity + opacityDistribution.highOpacity) {
          tile.forceOpacity = 0.7 + Math.random() * 0.3;
        } else {
          tile.forceOpacity = 0.3 + Math.random() * 0.4;
        }
        tiles.push(tile);
        generatedTiles++;
      }
    }
    console.log(`Generated ${tiles.length} field tiles (target: ${finalTargetTiles})`);
    const imageStats = {
      uniqueImagesUsed: new Set([...this.imageUsageCount.entries()].filter(([_, count]) => count > 0).map(([idx, _]) => idx)).size,
      maxUsageCount: Math.max(...[...this.imageUsageCount.values(), 0]),
      rotationsEnabled: useRotations,
      maxRotation,
      totalTiles: tiles.length
    };
    console.log("Field tile generation stats:", imageStats);
  }
  createDramaticTile(baseSize, dramaticScale, isFocalStyle) {
    const targetFocalPos = { x: this.canvas.width / 2, y: this.canvas.height / 2 };
    const dramaticSize = baseSize * dramaticScale;
    const offsetX = (Math.random() - 0.5) * dramaticSize * 0.3;
    const offsetY = (Math.random() - 0.5) * dramaticSize * 0.3;
    const dramaticX = targetFocalPos.x - dramaticSize / 2 + offsetX;
    const dramaticY = targetFocalPos.y - dramaticSize / 2 + offsetY;
    return {
      x: dramaticX,
      y: dramaticY,
      width: dramaticSize,
      height: dramaticSize,
      scale: dramaticScale,
      isDramaticCandidate: true,
      forceOpacity: 1
    };
  }
  assignOpacity(tile, dramaticTileData) {
    if (tile.isDramaticCandidate) return 1;
    const rand = Math.random();
    if (rand < 0.07) return 1;
    if (rand < 0.3) return 0.5 + Math.random() * 0.3;
    return null;
  }
};
export {
  TilingGenerator
};
//# sourceMappingURL=___src_legacy_js_collage_tilingGenerator__js.js.map
