{
  "version": 3,
  "sources": ["../../../src/legacy/js/collage/fragmentsGenerator.js"],
  "sourcesContent": ["/**\n * Fragments Generator for Assemblage\n * Handles fragments-specific collage generation with enhanced parameters\n */\n\nexport class FragmentsGenerator {\n    constructor(ctx, canvas) {\n        this.ctx = ctx;\n        this.canvas = canvas;\n        \n        // Set default canvas dimensions if not provided\n        if (!this.canvas) {\n            this.canvas = {\n                width: 1200,\n                height: 800\n            };\n        }\n        \n        // Ensure canvas has dimensions\n        if (!this.canvas.width || !this.canvas.height) {\n            this.canvas.width = 1200;\n            this.canvas.height = 800;\n        }\n    }\n\n    generateBackgroundColor() {\n        // Array of vibrant background colors\n        const colors = [\n            '#FF6B6B', // Coral Red\n            '#4ECDC4', // Turquoise\n            '#45B7D1', // Sky Blue\n            '#96CEB4', // Sage Green\n            '#FFEEAD', // Cream\n            '#D4A5A5', // Dusty Rose\n            '#9B59B6', // Purple\n            '#3498DB', // Blue\n            '#E67E22', // Orange\n            '#2ECC71'  // Green\n        ];\n        return colors[Math.floor(Math.random() * colors.length)];\n    }\n\n    calculateRequiredScale(image, targetWidth, targetHeight, minVisibility = 0.7) {\n        const imgRatio = image.naturalWidth / image.naturalHeight;\n        const targetRatio = targetWidth / targetHeight;\n        \n        let scale;\n        if (imgRatio > targetRatio) {\n            // Image is wider than target\n            scale = targetHeight / image.naturalHeight;\n        } else {\n            // Image is taller than target\n            scale = targetWidth / image.naturalWidth;\n        }\n        \n        // Account for minimum visibility requirement\n        const minScale = Math.max(\n            minVisibility / imgRatio,\n            minVisibility * imgRatio\n        );\n        \n        return Math.max(scale, minScale);\n    }\n\n    async generateFragments(images, fortuneText, parameters = {}) {\n        // console.log('Starting fragment generation with parameters:', {\n        //     variation: parameters.variation,\n        //     complexity: parameters.complexity,\n        //     maxFragments: parameters.maxFragments,\n        //     canvasWidth: this.canvas.width,\n        //     canvasHeight: this.canvas.height\n        // });\n\n        // Clear canvas and set background\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        this.ctx.fillStyle = this.generateBackgroundColor();\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n        // Filter out invalid images and check scaling requirements\n        const validImages = [];\n        const MAX_ATTEMPTS = 5;\n        \n        for (const image of images) {\n            if (!image || !image.complete || image.naturalWidth === 0) continue;\n            \n            // Calculate fragment dimensions based on variation\n            let fragmentWidth, fragmentHeight;\n            if (parameters.variation === 'Organic') {\n                const size = this.calculateOrganicSize(this.canvas.width, this.canvas.height);\n                fragmentWidth = size.width;\n                fragmentHeight = size.height;\n            } else if (parameters.variation === 'Focal') {\n                const size = this.calculateFocalSize(this.canvas.width, this.canvas.height, this.canvas.width/2, this.canvas.height/2);\n                fragmentWidth = size.width;\n                fragmentHeight = size.height;\n            } else {\n                const size = this.calculateClassicSize(this.canvas.width, this.canvas.height);\n                fragmentWidth = size.width;\n                fragmentHeight = size.height;\n            }\n            \n            // Calculate required scale for this image\n            const requiredScale = this.calculateRequiredScale(\n                image,\n                fragmentWidth,\n                fragmentHeight\n            );\n            \n            // Check if this scale is within our acceptable range\n            const maxAllowedScale = parameters.variation === 'Focal' ? 2.5 : 2.0;\n            if (requiredScale <= maxAllowedScale) {\n                validImages.push(image);\n            }\n        }\n\n        if (validImages.length === 0) {\n            console.warn('No valid images found that meet scaling requirements');\n            return;\n        }\n\n        // Calculate number of fragments\n        const complexityVariation = 0.75 + Math.random() * 0.3;\n        const numFragments = Math.min(\n            Math.max(3, Math.floor(validImages.length * parameters.complexity * 0.7 * complexityVariation)),\n            parameters.maxFragments || 8\n        );\n\n        const fragments = [];\n        const margin = 0;\n\n        for (let i = 0; i < numFragments; i++) {\n            // Calculate fragment dimensions based on variation\n            let fragmentWidth, fragmentHeight;\n            if (parameters.variation === 'Organic') {\n                const size = this.calculateOrganicSize(this.canvas.width, this.canvas.height);\n                fragmentWidth = size.width;\n                fragmentHeight = size.height;\n            } else if (parameters.variation === 'Focal') {\n                const size = this.calculateFocalSize(this.canvas.width, this.canvas.height, this.canvas.width/2, this.canvas.height/2);\n                fragmentWidth = size.width;\n                fragmentHeight = size.height;\n            } else {\n                const size = this.calculateClassicSize(this.canvas.width, this.canvas.height);\n                fragmentWidth = size.width;\n                fragmentHeight = size.height;\n            }\n\n            // Calculate position with margin\n            const maxX = this.canvas.width - fragmentWidth;\n            const maxY = this.canvas.height - fragmentHeight;\n            const x = margin + Math.random() * (maxX - 2 * margin);\n            const y = margin + Math.random() * (maxY - 2 * margin);\n\n            // Create fragment with calculated position\n            const fragment = {\n                image: validImages[i % validImages.length],\n                x: x,\n                y: y,\n                width: fragmentWidth,\n                height: fragmentHeight,\n                rotation: Math.random() < 0.7 ? 0 : Math.random() * 0.2,\n                depth: Math.random(),\n                mask: {\n                    enabled: Math.random() < 0.30,\n                    type: ['circle', 'triangle', 'rectangle', 'ellipse', 'diamond', 'hexagon', 'arc', 'arch', 'circle', 'triangle', 'rectangle'][Math.floor(Math.random() * 11)]\n                }\n            };\n            fragments.push(fragment);\n        }\n\n        // Sort fragments by depth\n        fragments.sort((a, b) => a.depth - b.depth);\n\n        return fragments;\n    }\n\n    generateFragmentsByVariation(fragments, count, sizeTiers, variation, images, imageIndices, allowImageRepetition) {\n        const centerX = this.canvas.width / 2;\n        const centerY = this.canvas.height / 2;\n        \n        // Track image usage for non-repetition mode\n        let currentIndex = 0;\n        \n        for (let i = 0; i < count; i++) {\n            // Reduced position bias for more even distribution\n            const positionBias = Math.random() < 0.3 ? 0.05 : 0; // Reduced from 0.1 to 0.05\n            let x = (Math.random() * (1 - 2 * positionBias) + positionBias) * this.canvas.width;\n            let y = (Math.random() * (1 - 2 * positionBias) + positionBias) * this.canvas.height;\n            \n            // Add slight bias towards center for better composition\n            const centerBias = 0.05; // Reduced from 0.1 to allow more edge bleeding\n            x = x * (1 - centerBias) + centerX * centerBias;\n            y = y * (1 - centerBias) + centerY * centerBias;\n            \n            // ENHANCED: Add back a moderate amount of rotation\n            let rotation = 0; // Default to zero rotation\n            \n            // 75% chance of exactly zero rotation\n            if (Math.random() >= 0.75) {\n                // Only 25% of fragments get any rotation at all\n                const rotationAmount = Math.random() * 0.15; // Maximum of ~8-9 degrees in radians\n                rotation = (Math.random() < 0.5 ? -1 : 1) * rotationAmount;\n            }\n            \n            let baseSize;\n            if (variation === 'Organic') {\n                baseSize = this.calculateOrganicSize(this.canvas.width, this.canvas.height);\n            } else if (variation === 'Focal') {\n                baseSize = this.calculateFocalSize(this.canvas.width, this.canvas.height, x, y);\n            } else {\n                baseSize = this.calculateClassicSize(this.canvas.width, this.canvas.height);\n            }\n            \n            // ENHANCED: More varied aspect ratios\n            const aspectVariation = Math.random() * 0.6 + 0.7; // Wider range (0.7-1.3)\n            const width = baseSize.width;\n            const height = baseSize.height;\n            \n            // Allow fragments to overflow by up to 95% of their width/height for more dramatic edge bleeding\n            const overflowAllowed = Math.random() < 0.4 ? 0.95 : 0.75; // 40% chance of extensive bleeding (95%), otherwise standard (75%)\n            \n            // Calculate position with significantly reduced overlap\n            const minDistance = Math.max(width, height) * 1.1; // Increased from 0.8 to 1.1 for much more spacing between fragments\n            let attempts = 0;\n            let validPosition = false;\n            \n            while (!validPosition && attempts < 20) { // Increased attempts from 15 to 20 for better placement\n                // Calculate new position\n                x = Math.max(-width * overflowAllowed, Math.min(x, this.canvas.width - width * (1 - overflowAllowed)));\n                y = Math.max(-height * overflowAllowed, Math.min(y, this.canvas.height - height * (1 - overflowAllowed)));\n                \n                // Check distance from other fragments\n                validPosition = true;\n                let overlappingCount = 0;\n                for (const existingFragment of fragments) {\n                    const dx = x - existingFragment.x;\n                    const dy = y - existingFragment.y;\n                    const distance = Math.sqrt(dx * dx + dy * dy);\n                    \n                    // Adjust overlap allowance based on fragment sizes\n                    // Allow more overlap between very different sized fragments\n                    const sizeRatio = Math.max(\n                        width / existingFragment.width,\n                        existingFragment.width / width\n                    );\n                    \n                    // More overlap allowed when fragments have very different sizes\n                    const overlapFactor = sizeRatio > 2.5 ? 0.4 : 0.9; // 0.4 for very disparate sizes, 0.9 for similar sizes\n                    \n                    // Calculate minimum non-overlapping distance\n                    const minRequiredDistance = (width + existingFragment.width) * overlapFactor;\n                    \n                    // Check if fragments overlap too much\n                    if (distance < minRequiredDistance) {\n                        overlappingCount++;\n                        if (overlappingCount >= 1) { // Reduced from 2 to 1 to allow max 1 overlapping fragment\n                            validPosition = false;\n                            // Move fragments farther apart with more directed adjustments\n                            const moveDirection = {x: dx || 0.1, y: dy || 0.1}; // Avoid zero values\n                            const moveDistance = minDistance * 1.8; // Increased from 1.5 to 1.8\n                            const magnitude = Math.sqrt(moveDirection.x * moveDirection.x + moveDirection.y * moveDirection.y);\n                            // Move away from existing fragment in the direction of the vector between them\n                            x += (moveDirection.x / magnitude) * moveDistance * (0.8 + Math.random() * 0.4);\n                            y += (moveDirection.y / magnitude) * moveDistance * (0.8 + Math.random() * 0.4);\n                            break;\n                        }\n                    }\n                }\n                attempts++;\n            }\n            \n            // Log fragment position and overflow\n            console.log(`Fragment ${i} position:`, {\n                x, y,\n                width, height,\n                overflowAllowed,\n                attempts,\n                validPosition,\n                canvasBounds: {\n                    minX: -width * overflowAllowed,\n                    maxX: this.canvas.width - width * (1 - overflowAllowed),\n                    minY: -height * overflowAllowed,\n                    maxY: this.canvas.height - height * (1 - overflowAllowed)\n                }\n            });\n            \n            // Select image based on repetition setting\n            let imgIndex;\n            if (allowImageRepetition) {\n                imgIndex = Math.floor(Math.random() * images.length);\n            } else {\n                imgIndex = imageIndices[currentIndex % imageIndices.length];\n                currentIndex++;\n            }\n            \n            fragments.push({\n                img: imgIndex,\n                x, y, width, height,\n                rotation,\n                depth: Math.random()\n            });\n        }\n    }\n\n    calculateOrganicSize(width, height) {\n        // More dramatic size variation with bias towards extremes\n        // Create a bimodal distribution - either quite small or quite large\n        const sizeCategory = Math.random();\n        let baseSize;\n        \n        if (sizeCategory < 0.35) { // 35% chance of smaller fragments\n            baseSize = 0.15 + Math.random() * 0.1; // 0.15-0.25 range (smaller)\n        } else if (sizeCategory < 0.85) { // 50% chance of medium fragments\n            baseSize = 0.2 + Math.random() * 0.05; // 0.2-0.25 range (medium)\n        } else if (sizeCategory < 0.95) { // 10% chance of larger fragments\n            baseSize = 0.35 + Math.random() * 0.15; // 0.35-0.5 range (larger)\n        } else { // 5% chance of medium fragments (fallback)\n            baseSize = 0.2 + Math.random() * 0.05; // 0.2-0.25 range (medium)\n        }\n        \n        // Add more dramatic variation to width and height\n        const widthVariation = 0.5 + Math.random() * 0.5; // 0.5-1.0 range\n        const heightVariation = 0.5 + Math.random() * 0.5; // 0.5-1.0 range\n        \n        return {\n            width: width * baseSize * widthVariation,\n            height: height * baseSize * heightVariation\n        };\n    }\n\n    calculateFocalSize(width, height, x, y) {\n        // Calculate distance from center (0 to 1)\n        const centerX = 0.5;\n        const centerY = 0.5;\n        const distanceFromCenter = Math.sqrt(\n            Math.pow(x/width - centerX, 2) + Math.pow(y/height - centerY, 2)\n        );\n        \n        // More dramatic size difference between center and edges\n        // Central elements can be up to 2x the size of edge elements\n        const sizeCategory = Math.random();\n        let baseSize;\n        \n        if (distanceFromCenter < 0.3) { // Near center - bigger elements\n            if (sizeCategory < 0.6) { // 60% chance of medium focal elements\n                baseSize = 0.2 + (1 - distanceFromCenter) * 0.05; // 0.2-0.25 range\n            } else if (sizeCategory < 0.9) { // 30% chance of very large focal elements\n                baseSize = 0.35 + (1 - distanceFromCenter) * 0.15; // 0.35-0.5 range\n            } else { // 10% chance of medium focal elements (fallback)\n                baseSize = 0.2 + (1 - distanceFromCenter) * 0.05; // 0.2-0.25 range\n            }\n        } else { // Away from center - smaller elements\n            if (sizeCategory < 0.7) { // 70% chance of small peripheral elements\n                baseSize = 0.15 + (1 - distanceFromCenter) * 0.1; // 0.15-0.25 range\n            } else { // 30% chance of medium peripheral elements\n                baseSize = 0.2 + (1 - distanceFromCenter) * 0.05; // 0.2-0.25 range\n            }\n        }\n        \n        // Add variation with more range\n        const variation = 0.6 + Math.random() * 0.4; // 0.6-1.0 range\n        \n        return {\n            width: width * baseSize * variation,\n            height: height * baseSize * variation\n        };\n    }\n\n    calculateClassicSize(width, height) {\n        // Create more dramatic size variations for classic layout\n        const sizeCategory = Math.random();\n        let baseSize;\n        \n        if (sizeCategory < 0.3) { // 30% chance of smaller fragments\n            baseSize = 0.15 + Math.random() * 0.1; // 0.15-0.25 range (smaller)\n        } else if (sizeCategory < 0.8) { // 50% chance of medium fragments\n            baseSize = 0.2 + Math.random() * 0.05; // 0.2-0.25 range (medium)\n        } else if (sizeCategory < 0.9) { // 10% chance of larger fragments\n            baseSize = 0.35 + Math.random() * 0.15; // 0.35-0.5 range (larger)\n        } else { // 10% chance of medium fragments (fallback)\n            baseSize = 0.2 + Math.random() * 0.05; // 0.2-0.25 range (medium)\n        }\n        \n        // Add more dramatic variation\n        const variation = 0.6 + Math.random() * 0.4; // 0.6-1.0 range\n        \n        return {\n            width: width * baseSize * variation,\n            height: height * baseSize * variation\n        };\n    }\n\n    postProcessFragments(fragments, variation) {\n        // Create more distinct layering with grouped depth values\n        const layerCount = 5; // Increased from 4 to 5 for more depth variation\n        fragments.forEach(fragment => {\n            const layerIndex = Math.floor(fragment.depth * layerCount);\n            fragment.depth = (layerIndex + Math.random() * 0.8) / layerCount; // Increased random factor\n            \n            // Force moderate rotation for some fragments\n            if (Math.random() < 0.75) { // 75% chance to have moderate rotation\n                fragment.rotation = (Math.random() < 0.5 ? -1 : 1) * (Math.random() * 0.12); // Up to ~7 degrees\n            } else { // 25% chance to have zero rotation\n                fragment.rotation = 0;\n            }\n        });\n        \n        // Ensure at least one fragment has 100% opacity\n        if (fragments.length > 0) {\n            let maxDepthFragment = fragments[0];\n            fragments.forEach(fragment => {\n                if (fragment.depth > maxDepthFragment.depth) {\n                    maxDepthFragment = fragment;\n                }\n            });\n            maxDepthFragment.forceFullOpacity = true;\n            \n            // Key fragments (highest opacity) often have minimal rotation for stability\n            if (Math.random() < 0.7) {\n                maxDepthFragment.rotation = 0;\n            }\n        }\n        \n        // Sort fragments by depth\n        fragments.sort((a, b) => a.depth - b.depth);\n        \n        // Special handling for Focal variation\n        if (variation === 'Focal') {\n            const fragmentsCopy = [...fragments];\n            fragmentsCopy.sort((a, b) => (b.width * b.height) - (a.width * a.height));\n            const largeFragmentThreshold = fragmentsCopy[Math.floor(fragments.length * 0.3)].width * \n                                        fragmentsCopy[Math.floor(fragments.length * 0.3)].height;\n            \n            fragments.forEach(fragment => {\n                if (fragment.width * fragment.height >= largeFragmentThreshold && Math.random() < 0.8) {\n                    fragment.depth = 0.7 + Math.random() * 0.3;\n                    \n                    // Larger focal elements have minimal rotation for visual stability\n                    if (Math.random() < 0.7) { // 70% chance of minimal rotation\n                        fragment.rotation = (Math.random() < 0.5 ? -1 : 1) * (Math.random() * 0.05); // Max ~3 degrees\n                    } else {\n                        // 30% chance of slightly more rotation, but still limited\n                        fragment.rotation = (Math.random() < 0.5 ? -1 : 1) * (Math.random() * 0.1); // Max ~6 degrees\n                    }\n                }\n            });\n            \n            fragments.sort((a, b) => a.depth - b.depth);\n        }\n    }\n\n    shuffleArray(array) {\n        for (let i = array.length - 1; i > 0; i--) {\n            const j = Math.floor(Math.random() * (i + 1));\n            [array[i], array[j]] = [array[j], array[i]];\n        }\n    }\n\n    drawFragment(fragment, ctx) {\n        console.log('Drawing fragment:', fragment);\n        const { x, y, width, height, image, rotation, mask } = fragment;\n        \n        // Validate fragment properties\n        if (!image || typeof image === 'undefined') {\n            console.warn('Invalid image for fragment:', fragment);\n            return;\n        }\n        \n        if (isNaN(x) || isNaN(y) || isNaN(width) || isNaN(height)) {\n            console.warn('Invalid fragment dimensions or position:', { x, y, width, height });\n            return;\n        }\n        \n        // Vary scale based on fragment size for more visual interest\n        // Smaller fragments get slightly larger scale, larger fragments get normal scale\n        const canvasArea = this.canvas.width * this.canvas.height;\n        const fragmentArea = width * height;\n        const fragmentSizeRatio = fragmentArea / canvasArea;\n        \n        // Scale inversely proportional to fragment size\n        // Small fragments get scale up to 1.3, large fragments get scale around 1.0-1.1\n        const drawScale = 1.0 + Math.max(0, 0.3 - fragmentSizeRatio * 20);\n        \n        // Force zero rotation when drawing to ensure stable presentation\n        const effectiveRotation = Math.abs(rotation) < 0.01 ? 0 : rotation; // Treat tiny rotations as zero\n        \n        ctx.save();\n        ctx.translate(x + width/2, y + height/2);\n        ctx.rotate(effectiveRotation);\n        ctx.scale(drawScale, drawScale);\n        \n        // Apply masking if enabled\n        if (mask && mask.enabled) {\n            // Create clipping path based on mask type\n            this.applyMask(ctx, mask.type, width, height);\n            ctx.clip();\n        }\n        \n        // Draw image\n        ctx.drawImage(image, -width/2, -height/2, width, height);\n        ctx.restore();\n        \n        console.log('Fragment drawn at position:', x, y, 'with dimensions:', width, height, 'scale:', drawScale);\n    }\n    \n    applyMask(ctx, maskType, width, height) {\n        const centerX = 0;\n        const centerY = 0;\n        const size = Math.min(width, height) * 0.9; // Scale to 90% of the smaller dimension\n        \n        ctx.beginPath();\n        \n        switch (maskType) {\n            case 'circle':\n                ctx.arc(centerX, centerY, size/2, 0, Math.PI * 2);\n                break;\n                \n            case 'triangle':\n                ctx.moveTo(centerX, centerY - size/2); // Top\n                ctx.lineTo(centerX + size/2, centerY + size/2); // Bottom right\n                ctx.lineTo(centerX - size/2, centerY + size/2); // Bottom left\n                break;\n                \n            case 'rectangle':\n                ctx.rect(centerX - size/2, centerY - size/2, size, size);\n                break;\n                \n            case 'ellipse':\n                ctx.ellipse(centerX, centerY, size/2, size/3, 0, 0, Math.PI * 2);\n                break;\n                \n            case 'diamond':\n                ctx.moveTo(centerX, centerY - size/2); // Top\n                ctx.lineTo(centerX + size/2, centerY); // Right\n                ctx.lineTo(centerX, centerY + size/2); // Bottom\n                ctx.lineTo(centerX - size/2, centerY); // Left\n                break;\n                \n            case 'hexagon':\n                const hexAngle = (Math.PI * 2) / 6;\n                for (let i = 0; i < 6; i++) {\n                    const x = centerX + size/2 * Math.cos(hexAngle * i);\n                    const y = centerY + size/2 * Math.sin(hexAngle * i);\n                    if (i === 0) ctx.moveTo(x, y);\n                    else ctx.lineTo(x, y);\n                }\n                break;\n                \n            case 'arc':\n                ctx.arc(centerX, centerY, size/2, 0, Math.PI * 2);\n                break;\n                \n            case 'arch':\n                ctx.arc(centerX, centerY, size/2, Math.PI * 0.2, Math.PI * 1.8);\n                break;\n                \n            default:\n                // Default to rectangle if mask type is unknown\n                ctx.rect(centerX - size/2, centerY - size/2, size, size);\n                break;\n        }\n        \n        ctx.closePath();\n    }\n} "],
  "mappings": "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",
  "names": []
}
