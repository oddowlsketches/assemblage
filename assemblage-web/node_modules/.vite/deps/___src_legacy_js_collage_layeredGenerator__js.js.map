{
  "version": 3,
  "sources": ["../../../src/legacy/js/collage/layeredGenerator.js"],
  "sourcesContent": ["class LayeredGenerator {\n    constructor(canvas, ctx) {\n        this.canvas = canvas;\n        this.ctx = ctx;\n    }\n\n    calculateRequiredScale(image, targetWidth, targetHeight, minVisibility = 0.7) {\n        const imgRatio = image.naturalWidth / image.naturalHeight;\n        const targetRatio = targetWidth / targetHeight;\n        \n        let scale;\n        if (imgRatio > targetRatio) {\n            // Image is wider than target\n            scale = targetHeight / image.naturalHeight;\n        } else {\n            // Image is taller than target\n            scale = targetWidth / image.naturalWidth;\n        }\n        \n        // Account for minimum visibility requirement\n        const minScale = Math.max(\n            minVisibility / imgRatio,\n            minVisibility * imgRatio\n        );\n        \n        return Math.max(scale, minScale);\n    }\n\n    generateLayers(images, parameters = {}) {\n        if (!images || images.length === 0) {\n            console.warn('No images provided for layered effect');\n            return;\n        }\n\n        console.log(`Generating layered effect with ${images.length} images`);\n\n        // Determine number of layers (2-5)\n        const numLayers = Math.floor(Math.random() * 4) + 2;\n        console.log(`Creating ${numLayers} layers`);\n\n        // Create layers with random images, scales, and positions\n        const layers = [];\n        const MAX_ATTEMPTS = 5; // Maximum number of attempts to find a suitable image\n        \n        for (let i = 0; i < numLayers; i++) {\n            let suitableImage = null;\n            let attempts = 0;\n            \n            while (!suitableImage && attempts < MAX_ATTEMPTS) {\n                const randomImage = images[Math.floor(Math.random() * images.length)];\n                \n                if (!randomImage || !randomImage.complete || randomImage.naturalWidth === 0) {\n                    attempts++;\n                    continue;\n                }\n                \n                // Calculate required scale for this image\n                const requiredScale = this.calculateRequiredScale(\n                    randomImage,\n                    this.canvas.width,\n                    this.canvas.height\n                );\n                \n                // Check if this scale is within our acceptable range (0.7 to 1.2)\n                if (requiredScale <= 1.2) {\n                    suitableImage = randomImage;\n                } else {\n                    attempts++;\n                }\n            }\n            \n            if (!suitableImage) {\n                console.warn(`Could not find suitable image after ${MAX_ATTEMPTS} attempts`);\n                continue;\n            }\n            \n            const scale = 0.7 + Math.random() * 0.5; // Scale between 0.7 and 1.2\n\n            // Calculate position to ensure at least one layer bleeds off the edges\n            const x = Math.random() * this.canvas.width * 1.2 - this.canvas.width * 0.1;\n            const y = Math.random() * this.canvas.height * 1.2 - this.canvas.height * 0.1;\n\n            layers.push({\n                image: suitableImage,\n                scale: scale,\n                x: x,\n                y: y,\n                opacity: i === 0 ? 1.0 : 0.3 + Math.random() * 0.4 // First layer full opacity, others 0.3-0.7\n            });\n        }\n\n        // Sort layers by scale (smaller scales drawn first)\n        layers.sort((a, b) => a.scale - b.scale);\n\n        // Draw layers\n        layers.forEach(layer => {\n            const { image, scale, x, y, opacity } = layer;\n\n            // Calculate dimensions maintaining aspect ratio\n            const aspectRatio = image.width / image.height;\n            let width = this.canvas.width * scale;\n            let height = width / aspectRatio;\n\n            // Ensure minimum visibility of 70%\n            if (height < this.canvas.height * 0.7) {\n                height = this.canvas.height * 0.7;\n                width = height * aspectRatio;\n            }\n\n            // Set opacity\n            this.ctx.globalAlpha = opacity;\n\n            // Draw the image\n            this.ctx.drawImage(image, x, y, width, height);\n        });\n\n        // Reset opacity\n        this.ctx.globalAlpha = 1.0;\n\n        return layers;\n    }\n}\n\nexport { LayeredGenerator }; "],
  "mappings": ";;;AAAA,IAAM,mBAAN,MAAuB;AAAA,EACnB,YAAY,QAAQ,KAAK;AACrB,SAAK,SAAS;AACd,SAAK,MAAM;AAAA,EACf;AAAA,EAEA,uBAAuB,OAAO,aAAa,cAAc,gBAAgB,KAAK;AAC1E,UAAM,WAAW,MAAM,eAAe,MAAM;AAC5C,UAAM,cAAc,cAAc;AAElC,QAAI;AACJ,QAAI,WAAW,aAAa;AAExB,cAAQ,eAAe,MAAM;AAAA,IACjC,OAAO;AAEH,cAAQ,cAAc,MAAM;AAAA,IAChC;AAGA,UAAM,WAAW,KAAK;AAAA,MAClB,gBAAgB;AAAA,MAChB,gBAAgB;AAAA,IACpB;AAEA,WAAO,KAAK,IAAI,OAAO,QAAQ;AAAA,EACnC;AAAA,EAEA,eAAe,QAAQ,aAAa,CAAC,GAAG;AACpC,QAAI,CAAC,UAAU,OAAO,WAAW,GAAG;AAChC,cAAQ,KAAK,uCAAuC;AACpD;AAAA,IACJ;AAEA,YAAQ,IAAI,kCAAkC,OAAO,MAAM,SAAS;AAGpE,UAAM,YAAY,KAAK,MAAM,KAAK,OAAO,IAAI,CAAC,IAAI;AAClD,YAAQ,IAAI,YAAY,SAAS,SAAS;AAG1C,UAAM,SAAS,CAAC;AAChB,UAAM,eAAe;AAErB,aAAS,IAAI,GAAG,IAAI,WAAW,KAAK;AAChC,UAAI,gBAAgB;AACpB,UAAI,WAAW;AAEf,aAAO,CAAC,iBAAiB,WAAW,cAAc;AAC9C,cAAM,cAAc,OAAO,KAAK,MAAM,KAAK,OAAO,IAAI,OAAO,MAAM,CAAC;AAEpE,YAAI,CAAC,eAAe,CAAC,YAAY,YAAY,YAAY,iBAAiB,GAAG;AACzE;AACA;AAAA,QACJ;AAGA,cAAM,gBAAgB,KAAK;AAAA,UACvB;AAAA,UACA,KAAK,OAAO;AAAA,UACZ,KAAK,OAAO;AAAA,QAChB;AAGA,YAAI,iBAAiB,KAAK;AACtB,0BAAgB;AAAA,QACpB,OAAO;AACH;AAAA,QACJ;AAAA,MACJ;AAEA,UAAI,CAAC,eAAe;AAChB,gBAAQ,KAAK,uCAAuC,YAAY,WAAW;AAC3E;AAAA,MACJ;AAEA,YAAM,QAAQ,MAAM,KAAK,OAAO,IAAI;AAGpC,YAAM,IAAI,KAAK,OAAO,IAAI,KAAK,OAAO,QAAQ,MAAM,KAAK,OAAO,QAAQ;AACxE,YAAM,IAAI,KAAK,OAAO,IAAI,KAAK,OAAO,SAAS,MAAM,KAAK,OAAO,SAAS;AAE1E,aAAO,KAAK;AAAA,QACR,OAAO;AAAA,QACP;AAAA,QACA;AAAA,QACA;AAAA,QACA,SAAS,MAAM,IAAI,IAAM,MAAM,KAAK,OAAO,IAAI;AAAA;AAAA,MACnD,CAAC;AAAA,IACL;AAGA,WAAO,KAAK,CAAC,GAAG,MAAM,EAAE,QAAQ,EAAE,KAAK;AAGvC,WAAO,QAAQ,WAAS;AACpB,YAAM,EAAE,OAAO,OAAO,GAAG,GAAG,QAAQ,IAAI;AAGxC,YAAM,cAAc,MAAM,QAAQ,MAAM;AACxC,UAAI,QAAQ,KAAK,OAAO,QAAQ;AAChC,UAAI,SAAS,QAAQ;AAGrB,UAAI,SAAS,KAAK,OAAO,SAAS,KAAK;AACnC,iBAAS,KAAK,OAAO,SAAS;AAC9B,gBAAQ,SAAS;AAAA,MACrB;AAGA,WAAK,IAAI,cAAc;AAGvB,WAAK,IAAI,UAAU,OAAO,GAAG,GAAG,OAAO,MAAM;AAAA,IACjD,CAAC;AAGD,SAAK,IAAI,cAAc;AAEvB,WAAO;AAAA,EACX;AACJ;",
  "names": []
}
