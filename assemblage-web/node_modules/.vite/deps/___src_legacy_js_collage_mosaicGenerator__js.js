import "./chunk-BUSYA2B4.js";

// src/legacy/js/collage/mosaicGenerator.js
var MosaicGenerator = class {
  /**
   * Create a new MosaicGenerator
   * @param {HTMLCanvasElement} canvas - The canvas to draw on
   * @param {Object} parameters - Parameters for mosaic generation
   */
  constructor(canvas, parameters = {}) {
    this.canvas = canvas;
    this.ctx = canvas ? canvas.getContext("2d") : null;
    this.parameters = parameters;
    if (!this.canvas) {
      this.canvas = {
        width: 1200,
        height: 800
      };
    }
    if (!this.canvas.width || !this.canvas.height) {
      this.canvas.width = 1200;
      this.canvas.height = 800;
    }
  }
  /**
   * Shuffle an array using Fisher-Yates algorithm
   * @param {Array} array - The array to shuffle
   * @returns {Array} - The shuffled array
   */
  shuffleArray(array) {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }
  /**
   * Generate a mosaic collage
   * @param {Array} images - Array of image objects
   * @param {Object} parameters - Parameters for mosaic generation
   * @returns {Promise<void>}
   */
  async generateMosaic(images, parameters = {}) {
    if (!images || images.length === 0) {
      console.warn("No images provided for mosaic generation");
      return [];
    }
    try {
      const complexity = parameters.complexity || 0.5;
      const baseGridSize = Math.ceil(Math.sqrt(images.length));
      let gridSize;
      const rand = Math.random();
      if (rand < 0.2) {
        gridSize = Math.floor(Math.random() * 2) + 2;
      } else if (rand < 0.4) {
        gridSize = Math.floor(Math.random() * 2) + 4;
      } else if (rand < 0.7) {
        gridSize = Math.floor(Math.random() * 2) + 6;
      } else {
        gridSize = Math.max(8, Math.min(10, Math.ceil(baseGridSize * (1 + complexity))));
      }
      const cellWidth = this.canvas.width / gridSize;
      const cellHeight = this.canvas.height / gridSize;
      const imageIndices = this.shuffleArray([...Array(images.length).keys()]);
      let currentIndex = 0;
      const totalTiles = gridSize * gridSize;
      const fullOpacityCount = Math.max(1, Math.ceil(totalTiles * 0.4));
      const fullOpacityTiles = new Array(totalTiles).fill(false);
      for (let i = 0; i < fullOpacityCount; i++) {
        const randomIndex = Math.floor(Math.random() * totalTiles);
        fullOpacityTiles[randomIndex] = true;
      }
      const tilesTouching = parameters.tilesTouching || false;
      const fragments = [];
      if (parameters.compositionStyle === "Focal") {
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;
        for (let i = 0; i < gridSize; i++) {
          for (let j = 0; j < gridSize; j++) {
            const x = i * cellWidth;
            const y = j * cellHeight;
            const dx = x - centerX;
            const dy = y - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const maxDistance = Math.sqrt(centerX * centerX + centerY * centerY);
            const scaleFactor = tilesTouching ? 0.5 : 1;
            const scale = 1 + (1 - distance / maxDistance) * 0.5 * scaleFactor;
            let imageIndex;
            if (parameters.allowImageRepetition) {
              imageIndex = Math.floor(Math.random() * images.length);
            } else {
              imageIndex = imageIndices[currentIndex % imageIndices.length];
              currentIndex++;
            }
            const image = images[imageIndex];
            const tileIndex = i * gridSize + j;
            const opacity = fullOpacityTiles[tileIndex] ? 1 : 0.7 + Math.random() * 0.3;
            const showCroppedPortion = Math.random() < 0.4;
            const finalX = x - (cellWidth * scale - cellWidth) / 2;
            const finalY = y - (cellHeight * scale - cellHeight) / 2;
            const finalWidth = cellWidth * scale;
            const finalHeight = cellHeight * scale;
            this.drawImage(
              image,
              finalX,
              finalY,
              finalWidth,
              finalHeight,
              true,
              opacity,
              showCroppedPortion
            );
            fragments.push({
              image,
              x: finalX,
              y: finalY,
              width: finalWidth,
              height: finalHeight,
              opacity,
              showCroppedPortion
            });
          }
        }
      } else {
        for (let i = 0; i < gridSize; i++) {
          for (let j = 0; j < gridSize; j++) {
            const x = i * cellWidth;
            const y = j * cellHeight;
            const offsetFactor = tilesTouching ? 0.05 : 0.1;
            const offsetX = (Math.random() - 0.5) * cellWidth * offsetFactor;
            const offsetY = (Math.random() - 0.5) * cellHeight * offsetFactor;
            const scaleFactor = tilesTouching ? 0.2 : 0.2;
            const scale = 1 + (Math.random() - 0.5) * scaleFactor;
            let imageIndex;
            if (parameters.allowImageRepetition) {
              imageIndex = Math.floor(Math.random() * images.length);
            } else {
              imageIndex = imageIndices[currentIndex % imageIndices.length];
              currentIndex++;
            }
            const image = images[imageIndex];
            const tileIndex = i * gridSize + j;
            const opacity = fullOpacityTiles[tileIndex] ? 1 : 0.7 + Math.random() * 0.3;
            const showCroppedPortion = Math.random() < 0.4;
            const finalX = x + offsetX;
            const finalY = y + offsetY;
            const finalWidth = cellWidth * scale;
            const finalHeight = cellHeight * scale;
            this.drawImage(
              image,
              finalX,
              finalY,
              finalWidth,
              finalHeight,
              true,
              opacity,
              showCroppedPortion
            );
            fragments.push({
              image,
              x: finalX,
              y: finalY,
              width: finalWidth,
              height: finalHeight,
              opacity,
              showCroppedPortion
            });
          }
        }
      }
      return fragments;
    } catch (error) {
      console.error("Error generating mosaic:", error);
      return [];
    }
  }
  /**
   * Draw an image with optional cropping and opacity
   * @param {HTMLImageElement} image - The image to draw
   * @param {number} x - X position
   * @param {number} y - Y position
   * @param {number} width - Width of the destination rectangle
   * @param {number} height - Height of the destination rectangle
   * @param {boolean} crop - Whether to crop the image
   * @param {number} forceOpacity - Forced opacity value (0-1)
   * @param {boolean} showCroppedPortion - Whether to show a cropped portion
   * @param {number} rotation - Rotation angle in degrees
   */
  drawImage(image, x, y, width, height, crop = false, forceOpacity = null, showCroppedPortion = false, rotation = 0) {
    if (!this.ctx || !image) return;
    this.ctx.save();
    const opacity = forceOpacity !== null ? forceOpacity : 1;
    this.ctx.globalAlpha = opacity;
    this.ctx.translate(x + width / 2, y + height / 2);
    if (rotation) {
      this.ctx.rotate(rotation * Math.PI / 180);
    }
    this.ctx.translate(-width / 2, -height / 2);
    if (showCroppedPortion) {
      const cropX = Math.random() * (image.width - width);
      const cropY = Math.random() * (image.height - height);
      this.ctx.drawImage(
        image,
        cropX,
        cropY,
        width,
        height,
        0,
        0,
        width,
        height
      );
    } else {
      this.ctx.drawImage(image, 0, 0, width, height);
    }
    this.ctx.restore();
  }
};
export {
  MosaicGenerator
};
//# sourceMappingURL=___src_legacy_js_collage_mosaicGenerator__js.js.map
