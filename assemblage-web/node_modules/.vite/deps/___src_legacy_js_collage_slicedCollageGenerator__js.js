import "./chunk-BUSYA2B4.js";

// src/legacy/js/collage/slicedCollageGenerator.js
var SlicedCollageGenerator = class {
  constructor(ctx, canvas) {
    this.ctx = ctx;
    this.canvas = canvas;
    if (!this.canvas) {
      this.canvas = {
        width: 1200,
        height: 800
      };
    }
    if (!this.canvas.width || !this.canvas.height) {
      this.canvas.width = 1200;
      this.canvas.height = 800;
    }
  }
  generateBackgroundColor() {
    const colors = [
      "#FF6B6B",
      // Coral Red
      "#4ECDC4",
      // Turquoise
      "#45B7D1",
      // Sky Blue
      "#96CEB4",
      // Sage Green
      "#FFEEAD",
      // Cream
      "#D4A5A5",
      // Dusty Rose
      "#9B59B6",
      // Purple
      "#3498DB",
      // Blue
      "#E67E22",
      // Orange
      "#2ECC71"
      // Green
    ];
    return colors[Math.floor(Math.random() * colors.length)];
  }
  // Calculate required scale for an image based on target dimensions
  calculateRequiredScale(image, targetWidth, targetHeight, minVisibility = 0.7) {
    const imgRatio = image.naturalWidth / image.naturalHeight;
    const targetRatio = targetWidth / targetHeight;
    let scale;
    if (imgRatio > targetRatio) {
      scale = targetHeight / image.naturalHeight;
    } else {
      scale = targetWidth / image.naturalWidth;
    }
    const minScale = Math.max(
      minVisibility / imgRatio,
      minVisibility * imgRatio
    );
    return Math.max(scale, minScale);
  }
  async generateSliced(images, fortuneText, parameters = {}) {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.fillStyle = this.generateBackgroundColor();
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    const validImages = images.filter((img) => img && img.complete && img.naturalWidth > 0 && img.naturalHeight > 0);
    if (validImages.length === 0) {
      console.warn("No valid images provided for sliced generation");
      return [];
    }
    const sliceBehavior = parameters.sliceBehavior || "random";
    let selectedImage = null;
    let secondImage = null;
    console.log("Slice behavior:", sliceBehavior);
    let numSlices;
    if (sliceBehavior === "random") {
      numSlices = Math.min(
        Math.max(3, Math.floor(Math.random() * 5) + 3),
        parameters.maxSlices || 7
      );
      console.log("Random behavior: using", numSlices, "slices");
    } else if (sliceBehavior === "single-image") {
      numSlices = Math.min(
        Math.max(5, Math.floor(Math.random() * 46) + 5),
        parameters.maxSlices || 50
      );
      console.log("Single image behavior: using", numSlices, "slices");
    } else {
      numSlices = Math.min(
        Math.max(7, Math.floor(Math.random() * 44) + 7),
        parameters.maxSlices || 50
      );
      console.log("Alternating behavior: using", numSlices, "slices");
    }
    const baseStripWidth = this.canvas.width / numSlices;
    const baseStripHeight = this.canvas.height;
    const filteredImages = [];
    const MAX_ATTEMPTS = 5;
    for (const image of validImages) {
      const requiredScale = this.calculateRequiredScale(
        image,
        baseStripWidth,
        baseStripHeight
      );
      const maxAllowedScale = 2;
      if (requiredScale <= maxAllowedScale) {
        filteredImages.push(image);
      }
    }
    if (filteredImages.length === 0) {
      console.warn("No images found that meet scaling requirements, using all valid images");
      filteredImages.push(...validImages);
    }
    if (sliceBehavior === "single-image" && filteredImages.length > 0) {
      selectedImage = filteredImages[Math.floor(Math.random() * filteredImages.length)];
      console.log("Using single image for all slices:", selectedImage.src);
    } else if (sliceBehavior === "alternating" && filteredImages.length >= 2) {
      const randomIndex = Math.floor(Math.random() * filteredImages.length);
      selectedImage = filteredImages[randomIndex];
      secondImage = filteredImages[(randomIndex + 1) % filteredImages.length];
      console.log("Using alternating images for slices:", selectedImage.src, secondImage.src);
    } else {
      console.log("Using random images for slices");
    }
    const slices = this.createSlicedEffect(numSlices, filteredImages, selectedImage, secondImage, parameters);
    this.drawSlices(slices);
    return slices;
  }
  // Create a sliced effect with evenly divided strips
  createSlicedEffect(numberOfSlices, images, selectedImage, secondImage, parameters) {
    const slices = [];
    const baseStripWidth = this.canvas.width / numberOfSlices;
    const baseStripHeight = this.canvas.height;
    const variation = parameters.sliceWidthVariation || 0.1;
    let currentPosition = 0;
    let shuffledImages = [];
    if (!selectedImage) {
      shuffledImages = [...images];
      this.shuffleArray(shuffledImages);
      if (shuffledImages.length < numberOfSlices) {
        while (shuffledImages.length < numberOfSlices) {
          shuffledImages.push(...this.shuffleArray([...images]));
        }
      }
    }
    for (let i = 0; i < numberOfSlices; i++) {
      const widthVariation = selectedImage && !secondImage ? 0.2 : 0.1;
      const stripWidth = baseStripWidth * (1 + (Math.random() * widthVariation - widthVariation / 2));
      let imageToUse;
      if (selectedImage) {
        if (secondImage && i % 2 === 1) {
          imageToUse = secondImage;
        } else {
          imageToUse = selectedImage;
        }
      } else {
        imageToUse = shuffledImages[i];
      }
      const slice = {
        image: imageToUse,
        x: currentPosition,
        y: 0,
        width: stripWidth,
        height: baseStripHeight,
        rotation: 0,
        // Add slight opacity variation for single-image slices
        opacity: selectedImage && !secondImage ? 0.85 + Math.random() * 0.3 : 1,
        // Add offset properties for single-image and alternating behaviors
        imageOffsetX: selectedImage ? i / numberOfSlices : 0,
        imageOffsetY: 0
      };
      slices.push(slice);
      currentPosition += stripWidth;
    }
    if (slices.length > 0) {
      const lastSlice = slices[slices.length - 1];
      lastSlice.width = this.canvas.width - lastSlice.x;
    }
    return slices;
  }
  // Draw the slices
  drawSlices(slices) {
    for (const slice of slices) {
      this.drawSlice(slice);
    }
  }
  // Draw a single slice
  drawSlice(slice) {
    if (!slice.image || !slice.image.complete) return;
    this.ctx.save();
    this.ctx.globalAlpha = slice.opacity || 1;
    const imgAspectRatio = slice.image.naturalWidth / slice.image.naturalHeight;
    const sliceAspectRatio = slice.width / slice.height;
    let drawWidth, drawHeight;
    let offsetX = 0, offsetY = 0;
    if (slice.imageOffsetX !== void 0 || slice.imageOffsetY !== void 0) {
      if (imgAspectRatio > sliceAspectRatio) {
        drawHeight = slice.height;
        drawWidth = drawHeight * imgAspectRatio;
        offsetX = (drawWidth - slice.width) * (slice.imageOffsetX || 0);
      } else {
        drawWidth = slice.width;
        drawHeight = drawWidth / imgAspectRatio;
        offsetY = (drawHeight - slice.height) * (slice.imageOffsetY || 0);
      }
    } else {
      if (imgAspectRatio > sliceAspectRatio) {
        drawHeight = slice.height;
        drawWidth = drawHeight * imgAspectRatio;
        offsetX = (drawWidth - slice.width) / 2;
      } else {
        drawWidth = slice.width;
        drawHeight = drawWidth / imgAspectRatio;
        offsetY = (drawHeight - slice.height) / 2;
      }
    }
    this.ctx.beginPath();
    this.ctx.rect(slice.x, slice.y, slice.width, slice.height);
    this.ctx.clip();
    this.ctx.drawImage(
      slice.image,
      slice.x - offsetX,
      slice.y - offsetY,
      drawWidth,
      drawHeight
    );
    this.ctx.restore();
  }
  // Helper function to shuffle an array
  shuffleArray(array) {
    const newArray = [...array];
    for (let i = newArray.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
    }
    return newArray;
  }
};
export {
  SlicedCollageGenerator
};
//# sourceMappingURL=___src_legacy_js_collage_slicedCollageGenerator__js.js.map
