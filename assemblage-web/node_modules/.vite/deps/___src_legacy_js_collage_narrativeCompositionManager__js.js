import "./chunk-BUSYA2B4.js";

// src/legacy/js/collage/narrativeCompositionManager.js
var NarrativeCompositionManager = class {
  constructor(parameters = {}) {
    this.parameters = {
      ...parameters,
      canvasWidth: parameters.canvasWidth || window.innerWidth,
      canvasHeight: parameters.canvasHeight || window.innerHeight
    };
  }
  adjustOpacity(fragment, progress, depthOpacity = false) {
    fragment.opacity = 0.85 + Math.sin(progress * Math.PI) * 0.15;
    if (depthOpacity) {
      const minOpacity = 0.5;
      const maxOpacity = 1;
      fragment.opacity = minOpacity + (maxOpacity - minOpacity) * (1 - fragment.depth);
    }
  }
  createHexagonMask(element) {
    const width = element.width;
    const height = element.height;
    const centerX = width / 2;
    const centerY = height / 2;
    const radius = Math.min(width, height) / 2;
    const vertices = [];
    for (let i = 0; i < 6; i++) {
      const angle = i * Math.PI / 3 - Math.PI / 6;
      vertices.push({
        x: centerX + radius * Math.cos(angle),
        y: centerY + radius * Math.sin(angle)
      });
    }
    const path = new Path2D();
    path.moveTo(vertices[0].x, vertices[0].y);
    for (let i = 1; i < vertices.length; i++) {
      path.lineTo(vertices[i].x, vertices[i].y);
    }
    path.closePath();
    element.maskParams = {
      type: "hexagon",
      vertices,
      centerX,
      centerY,
      radius
    };
    return path;
  }
  createArcMask(element) {
    const width = element.width;
    const height = element.height;
    const centerX = width / 2;
    const centerY = height / 2;
    const arcRadius = Math.min(width, height) / 2;
    const arcWidth = Math.max(30, arcRadius * 0.2);
    const path = new Path2D();
    path.arc(centerX, centerY, arcRadius, 0, Math.PI * 2);
    const clipPath = new Path2D();
    clipPath.rect(0, 0, width, height);
    element.maskParams = {
      type: "arc",
      centerX,
      centerY,
      radius: arcRadius,
      width: arcWidth
    };
    return {
      path,
      clipPath
    };
  }
  async generate(images, fortuneText, effect, parameters = {}) {
    const ctx = this.parameters.ctx;
    const canvas = this.parameters.canvas;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const fragments = [];
    const numLayers = Math.min(images.length, 4);
    for (let i = 0; i < numLayers; i++) {
      const image = images[i];
      if (!image || !image.complete) continue;
      const scale = 0.8 + i * 0.1;
      const width = canvas.width * scale;
      const height = canvas.height * scale;
      const x = (canvas.width - width) / 2;
      const y = (canvas.height - height) / 2;
      const fragment = {
        image,
        x,
        y,
        width,
        height,
        depth: i / numLayers,
        opacity: 0.7 + i * 0.1
      };
      if (i % 2 === 0) {
        fragment.mask = this.createHexagonMask(fragment);
      } else {
        fragment.mask = this.createArcMask(fragment);
      }
      fragments.push(fragment);
    }
    fragments.forEach((fragment) => {
      ctx.save();
      ctx.globalAlpha = fragment.opacity;
      if (fragment.mask) {
        if (fragment.mask.path && fragment.mask.clipPath) {
          ctx.clip(fragment.mask.clipPath);
          ctx.drawImage(fragment.image, fragment.x, fragment.y, fragment.width, fragment.height);
        } else {
          ctx.clip(fragment.mask);
          ctx.drawImage(fragment.image, fragment.x, fragment.y, fragment.width, fragment.height);
        }
      } else {
        ctx.drawImage(fragment.image, fragment.x, fragment.y, fragment.width, fragment.height);
      }
      ctx.restore();
    });
    return fragments;
  }
};
export {
  NarrativeCompositionManager
};
//# sourceMappingURL=___src_legacy_js_collage_narrativeCompositionManager__js.js.map
