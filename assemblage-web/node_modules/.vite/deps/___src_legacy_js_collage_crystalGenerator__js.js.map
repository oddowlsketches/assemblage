{
  "version": 3,
  "sources": ["../../../src/legacy/js/collage/crystalGenerator.js"],
  "sourcesContent": ["/**\n * CrystalGenerator - Creates crystal-like effects with rotated and overlapping images\n */\n\nexport class CrystalGenerator {\n    constructor(canvas, parameters = {}) {\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d');\n        this.parameters = parameters;\n        this.imageUsageCount = new Map();\n        \n        // Initialize parameters with defaults\n        this.crystalComplexity = parameters.crystalComplexity || 0.5;\n        this.crystalDensity = parameters.crystalDensity || 0.5;\n        this.crystalOpacity = parameters.crystalOpacity || 0.7;\n        this.isolatedMode = parameters.isolatedMode || false;\n        this.addGlow = parameters.addGlow || false;\n        this.rotationRange = parameters.rotationRange || Math.PI / 4;\n        \n        console.log('CrystalGenerator initialized with parameters:', this.parameters);\n    }\n\n    async generateCrystalCollage(images) {\n        if (!images || images.length === 0) {\n            console.warn('No images provided for crystal collage');\n            return;\n        }\n        \n        // Reset image usage tracking\n        this.imageUsageCount.clear();\n        \n        // Clear canvas\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        \n        // Set background color\n        this.setBackgroundColor();\n        \n        // Calculate base size based on complexity\n        const baseSize = Math.max(50, Math.min(200, 100 + this.crystalComplexity * 150));\n        \n        // Calculate number of pieces based on density\n        const numPieces = Math.max(5, Math.min(20, 10 + this.crystalDensity * 15));\n        \n        const pieces = [];\n        \n        // Generate crystal pieces\n        for (let i = 0; i < numPieces; i++) {\n            const width = baseSize * (0.8 + Math.random() * 0.4);\n            const height = width * (0.8 + Math.random() * 0.4);\n            \n            // Random position within canvas bounds\n            const x = Math.random() * (this.canvas.width - width);\n            const y = Math.random() * (this.canvas.height - height);\n            \n            // Random rotation within range\n            const rotation = (Math.random() - 0.5) * this.rotationRange;\n            \n            // Random opacity based on crystalOpacity parameter\n            const opacity = 0.3 + Math.random() * this.crystalOpacity;\n            \n            // Determine crystal facet type\n            const facetType = this.getRandomFacetType();\n            \n            // Random image from the provided set\n            const imageIndex = Math.floor(Math.random() * images.length);\n            const image = images[imageIndex];\n            \n            // Update usage count\n            const currentCount = this.imageUsageCount.get(imageIndex) || 0;\n            this.imageUsageCount.set(imageIndex, currentCount + 1);\n            \n            pieces.push({\n                x, y, width, height, rotation, opacity, image, facetType\n            });\n        }\n        \n        // Sort pieces by opacity for proper layering\n        pieces.sort((a, b) => a.opacity - b.opacity);\n        \n        // Draw pieces\n        pieces.forEach(piece => {\n            this.ctx.save();\n            this.ctx.globalAlpha = piece.opacity;\n            \n            // Move to piece center for rotation\n            this.ctx.translate(piece.x + piece.width/2, piece.y + piece.height/2);\n            this.ctx.rotate(piece.rotation);\n            \n            // Create clipping path for crystal facet\n            this.drawCrystalFacet(piece.facetType, piece.width, piece.height);\n            this.ctx.clip();\n            \n            // Draw image\n            this.ctx.drawImage(piece.image, -piece.width/2, -piece.height/2, piece.width, piece.height);\n            \n            this.ctx.restore();\n        });\n        \n        // Add glow effect if enabled\n        if (this.addGlow) {\n            this.addGlowEffect();\n        }\n        \n        console.log('[DEBUG] Crystal collage generation completed');\n    }\n    \n    getRandomFacetType() {\n        const facetTypes = ['diamond', 'hexagon', 'triangle', 'rectangle', 'pentagon', 'octagon', 'star', 'circle'];\n        return facetTypes[Math.floor(Math.random() * facetTypes.length)];\n    }\n    \n    drawCrystalFacet(type, width, height) {\n        const centerX = 0;\n        const centerY = 0;\n        const size = Math.min(width, height) * 0.9; // Scale to 90% of the smaller dimension\n        \n        this.ctx.beginPath();\n        \n        switch (type) {\n            case 'diamond':\n                this.ctx.moveTo(centerX, centerY - size/2); // Top\n                this.ctx.lineTo(centerX + size/2, centerY); // Right\n                this.ctx.lineTo(centerX, centerY + size/2); // Bottom\n                this.ctx.lineTo(centerX - size/2, centerY); // Left\n                break;\n                \n            case 'hexagon':\n                const hexAngle = (Math.PI * 2) / 6;\n                for (let i = 0; i < 6; i++) {\n                    const x = centerX + size/2 * Math.cos(hexAngle * i);\n                    const y = centerY + size/2 * Math.sin(hexAngle * i);\n                    if (i === 0) this.ctx.moveTo(x, y);\n                    else this.ctx.lineTo(x, y);\n                }\n                break;\n                \n            case 'triangle':\n                this.ctx.moveTo(centerX, centerY - size/2); // Top\n                this.ctx.lineTo(centerX + size/2, centerY + size/2); // Bottom right\n                this.ctx.lineTo(centerX - size/2, centerY + size/2); // Bottom left\n                break;\n                \n            case 'rectangle':\n                this.ctx.rect(centerX - size/2, centerY - size/2, size, size);\n                break;\n                \n            case 'pentagon':\n                const pentAngle = (Math.PI * 2) / 5;\n                for (let i = 0; i < 5; i++) {\n                    const x = centerX + size/2 * Math.cos(pentAngle * i - Math.PI/2);\n                    const y = centerY + size/2 * Math.sin(pentAngle * i - Math.PI/2);\n                    if (i === 0) this.ctx.moveTo(x, y);\n                    else this.ctx.lineTo(x, y);\n                }\n                break;\n                \n            case 'octagon':\n                const octAngle = (Math.PI * 2) / 8;\n                for (let i = 0; i < 8; i++) {\n                    const x = centerX + size/2 * Math.cos(octAngle * i);\n                    const y = centerY + size/2 * Math.sin(octAngle * i);\n                    if (i === 0) this.ctx.moveTo(x, y);\n                    else this.ctx.lineTo(x, y);\n                }\n                break;\n                \n            case 'star':\n                const outerRadius = size/2;\n                const innerRadius = size/4;\n                const numPoints = 5;\n                const angleStep = (Math.PI * 2) / numPoints;\n                \n                for (let i = 0; i < numPoints * 2; i++) {\n                    const radius = i % 2 === 0 ? outerRadius : innerRadius;\n                    const angle = angleStep * i;\n                    const x = centerX + radius * Math.cos(angle - Math.PI/2);\n                    const y = centerY + radius * Math.sin(angle - Math.PI/2);\n                    if (i === 0) this.ctx.moveTo(x, y);\n                    else this.ctx.lineTo(x, y);\n                }\n                break;\n                \n            case 'circle':\n                this.ctx.arc(centerX, centerY, size/2, 0, Math.PI * 2);\n                break;\n                \n            default:\n                // Default to diamond if type is unknown\n                this.ctx.moveTo(centerX, centerY - size/2);\n                this.ctx.lineTo(centerX + size/2, centerY);\n                this.ctx.lineTo(centerX, centerY + size/2);\n                this.ctx.lineTo(centerX - size/2, centerY);\n                break;\n        }\n        \n        this.ctx.closePath();\n    }\n    \n    setBackgroundColor() {\n        // Generate a subtle background color\n        const hue = Math.random() * 360;\n        this.ctx.fillStyle = `hsla(${hue}, 20%, 95%, 0.3)`;\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n    }\n    \n    addGlowEffect() {\n        const gradient = this.ctx.createRadialGradient(\n            this.canvas.width/2, this.canvas.height/2, 0,\n            this.canvas.width/2, this.canvas.height/2, this.canvas.width/2\n        );\n        \n        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.1)');\n        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');\n        \n        this.ctx.fillStyle = gradient;\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n    }\n} "],
  "mappings": "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",
  "names": []
}
