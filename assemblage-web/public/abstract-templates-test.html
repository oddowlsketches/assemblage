<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Abstract Templates Test - Assemblage</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: system-ui, -apple-system, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            margin-top: 0;
        }
        .canvas-container {
            width: 100%;
            height: 600px;
            background: #232323;
            border-radius: 8px;
            margin: 20px 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        canvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        select, button {
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        button {
            background: #2196F3;
            color: white;
            border: none;
            cursor: pointer;
        }
        pre {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            overflow: auto;
            max-height: 300px;
        }
        .feedback-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .feedback-button {
            padding: 8px 16px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
        }
        .feedback-good {
            background: #4CAF50;
            color: white;
        }
        .feedback-bad {
            background: #F44336;
            color: white;
        }
        .template-info {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Abstract Templates Test</h1>
        
        <div class="controls">
            <select id="templateSelect">
                <!-- Templates will be populated here -->
            </select>
            <button id="generateBtn">Generate New Version</button>
        </div>
        
        <div class="canvas-container">
            <canvas id="canvas" width="800" height="600"></canvas>
        </div>
        
        <div class="feedback-buttons">
            <button id="feedbackGood" class="feedback-button feedback-good">üëç Good Composition</button>
            <button id="feedbackBad" class="feedback-button feedback-bad">üëé Poor Composition</button>
        </div>
        
        <div class="template-info">
            <h2>Template: <span id="templateName"></span></h2>
            <p id="templateDescription"></p>
            
            <details>
                <summary>Template Data</summary>
                <pre id="templateData"></pre>
            </details>
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const templateSelect = document.getElementById('templateSelect');
        const generateBtn = document.getElementById('generateBtn');
        const templateData = document.getElementById('templateData');
        const templateName = document.getElementById('templateName');
        const templateDescription = document.getElementById('templateDescription');
        const feedbackGood = document.getElementById('feedbackGood');
        const feedbackBad = document.getElementById('feedbackBad');
        
        // Feedback history
        const feedbackHistory = [];
        
        // Abstract templates for testing
        const abstractTemplates = [
            {
                key: 'scrambledMosaic',
                name: 'Scrambled Mosaic',
                description: 'A grid of cells with various geometric shapes, like a fragmented mosaic with occasional blanks',
                defaultBG: '#FFFFFF',
                placements: [
                    { 
                        maskName: 'circle', 
                        x: 0.167, 
                        y: 0.125, 
                        width: 0.167, 
                        height: 0.25, 
                        rotation: 0,
                    },
                    { 
                        maskName: 'diamond', 
                        x: 0.333, 
                        y: 0.125, 
                        width: 0.167, 
                        height: 0.25, 
                        rotation: 15 
                    },
                    { 
                        maskName: 'hexagon', 
                        x: 0.500, 
                        y: 0.125, 
                        width: 0.167, 
                        height: 0.25, 
                        rotation: 0 
                    },
                    { 
                        maskName: 'triangle', 
                        x: 0.667, 
                        y: 0.125, 
                        width: 0.167, 
                        height: 0.25, 
                        rotation: 0 
                    },
                    { 
                        maskName: 'circle', 
                        x: 0.833, 
                        y: 0.125, 
                        width: 0.167, 
                        height: 0.25, 
                        rotation: 0 
                    },
                    { 
                        maskName: 'triangle', 
                        x: 0.167, 
                        y: 0.375, 
                        width: 0.167, 
                        height: 0.25, 
                        rotation: 0 
                    },
                    { 
                        maskName: 'hexagon', 
                        x: 0.333, 
                        y: 0.375, 
                        width: 0.167, 
                        height: 0.25, 
                        rotation: 30 
                    },
                    { 
                        maskName: 'circle', 
                        x: 0.500, 
                        y: 0.375, 
                        width: 0.167, 
                        height: 0.25, 
                        rotation: 0 
                    },
                    { 
                        maskName: 'triangle', 
                        x: 0.667, 
                        y: 0.375, 
                        width: 0.167, 
                        height: 0.25, 
                        rotation: -15 
                    },
                    { 
                        maskName: 'circle', 
                        x: 0.167, 
                        y: 0.625, 
                        width: 0.167, 
                        height: 0.25, 
                        rotation: 0 
                    },
                    { 
                        maskName: 'diamond', 
                        x: 0.333, 
                        y: 0.625, 
                        width: 0.167, 
                        height: 0.25, 
                        rotation: 0 
                    },
                    { 
                        maskName: 'diamond', 
                        x: 0.500, 
                        y: 0.625, 
                        width: 0.167, 
                        height: 0.25, 
                        rotation: 20 
                    },
                    { 
                        maskName: 'triangle', 
                        x: 0.833, 
                        y: 0.625, 
                        width: 0.167, 
                        height: 0.25, 
                        rotation: 0 
                    },
                    { 
                        maskName: 'hexagon', 
                        x: 0.167, 
                        y: 0.875, 
                        width: 0.167, 
                        height: 0.25, 
                        rotation: 0 
                    },
                    { 
                        maskName: 'hexagon', 
                        x: 0.500, 
                        y: 0.875, 
                        width: 0.167, 
                        height: 0.25, 
                        rotation: 40 
                    },
                    { 
                        maskName: 'triangle', 
                        x: 0.667, 
                        y: 0.875, 
                        width: 0.167, 
                        height: 0.25, 
                        rotation: 10 
                    },
                    { 
                        maskName: 'circle', 
                        x: 0.833, 
                        y: 0.875, 
                        width: 0.167, 
                        height: 0.25, 
                        rotation: 0 
                    }
                ],
                // Parameters for random variation
                paramRanges: {
                    position: 0.2, // How much to vary x/y (0-1)
                    size: 0.1,     // How much to vary width/height (0-1)
                    rotation: 0.3   // How much to vary rotation (0-1)
                }
            },
            {
                key: 'pairedCropAbstraction',
                name: 'Paired Crop Abstraction',
                description: 'Overlapping organic shapes creating a fluid, abstract composition',
                defaultBG: '#F0F5FA',
                placements: [
                    { 
                        maskName: 'blob', 
                        x: 0.40, 
                        y: 0.45, 
                        width: 0.50, 
                        height: 0.50, 
                        rotation: 0,
                    },
                    { 
                        maskName: 'blob', 
                        x: 0.60, 
                        y: 0.55, 
                        width: 0.25, 
                        height: 0.25, 
                        rotation: 12,
                    },
                    { 
                        maskName: 'polygon', 
                        x: 0.35, 
                        y: 0.30, 
                        width: 0.12, 
                        height: 0.12, 
                        rotation: 8,
                    }
                ],
                paramRanges: {
                    position: 0.3,
                    size: 0.2,
                    rotation: 0.5
                }
            },
            {
                key: 'floatingForms',
                name: 'Floating Forms',
                description: 'Abstract shapes floating freely in space with varied rotations and positions',
                defaultBG: '#F7F7F7',
                placements: [
                    { 
                        maskName: 'blob', 
                        x: 0.35, 
                        y: 0.40, 
                        width: 0.35, 
                        height: 0.35, 
                        rotation: 45 
                    },
                    { 
                        maskName: 'cloud', 
                        x: 0.55, 
                        y: 0.50, 
                        width: 0.20, 
                        height: 0.20, 
                        rotation: 180 
                    },
                    { 
                        maskName: 'blob', 
                        x: 0.25, 
                        y: 0.60, 
                        width: 0.20, 
                        height: 0.20, 
                        rotation: 270 
                    },
                    { 
                        maskName: 'polygon', 
                        x: 0.70, 
                        y: 0.20, 
                        width: 0.10, 
                        height: 0.10, 
                        rotation: 90 
                    },
                    { 
                        maskName: 'circle', 
                        x: 0.80, 
                        y: 0.30, 
                        width: 0.10, 
                        height: 0.10, 
                        rotation: 135 
                    }
                ],
                paramRanges: {
                    position: 0.4,
                    size: 0.2,
                    rotation: 0.6
                }
            },
            {
                key: 'slicedAbstraction',
                name: 'Sliced Abstraction',
                description: 'Horizontal slices with clean lines cutting across the image',
                defaultBG: '#F5F5F0',
                placements: [
                    {
                        maskName: 'slice',
                        x: 0.1,
                        y: 0.15,
                        width: 0.8,
                        height: 0.12,
                        rotation: 0
                    },
                    {
                        maskName: 'slice',
                        x: 0.1,
                        y: 0.32,
                        width: 0.8,
                        height: 0.12,
                        rotation: 0
                    },
                    {
                        maskName: 'slice',
                        x: 0.1,
                        y: 0.49,
                        width: 0.8,
                        height: 0.12,
                        rotation: 0
                    },
                    {
                        maskName: 'slice',
                        x: 0.1,
                        y: 0.66,
                        width: 0.8,
                        height: 0.12,
                        rotation: 0
                    },
                    {
                        maskName: 'slice',
                        x: 0.1,
                        y: 0.83,
                        width: 0.8,
                        height: 0.12,
                        rotation: 0
                    }
                ],
                paramRanges: {
                    position: 0.05, // Less variance for clean, straight slices
                    size: 0.05,
                    rotation: 0.1  // Allow for slight rotation
                }
            },
            {
                key: 'circularCutout',
                name: 'Circular Cutout',
                description: 'A single circular mask cutting through an image, reminiscent of the tree image example',
                defaultBG: '#FFFFFF',
                placements: [
                    {
                        maskName: 'circle',
                        x: 0.5,
                        y: 0.5,
                        width: 0.3,
                        height: 0.3,
                        rotation: 0,
                    }
                ],
                paramRanges: {
                    position: 0.1,
                    size: 0.1,
                    rotation: 0
                }
            }
        ];

        // Array of images
        const images = [];
        
        // Current template
        let currentTemplate = null;
        
        // Function to load images
        async function loadImages() {
            // Load 10 placeholders
            for (let i = 0; i < 10; i++) {
                const img = new Image();
                img.crossOrigin = "anonymous";
                // Use placeholder images
                img.src = `https://picsum.photos/seed/${i}/800/600`;
                await new Promise((resolve) => {
                    img.onload = resolve;
                    img.onerror = resolve; // Continue even if load fails
                });
                if (img.complete) {
                    images.push(img);
                }
            }
            console.log(`Loaded ${images.length} images`);
            
            // Generate initial template
            if (images.length > 0) {
                generateTemplate();
            }
        }
        
        // Function to draw masks of different shapes
        function drawMask(maskName, x, y, width, height, rotation) {
            ctx.save();
            
            // Move to the center of the mask
            ctx.translate(x + width/2, y + height/2);
            
            // Apply rotation if any
            if (rotation) {
                ctx.rotate(rotation * Math.PI / 180);
            }
            
            // Draw the mask shape based on its name
            ctx.beginPath();
            
            switch (maskName) {
                case 'circle':
                    // Circle mask
                    const radius = Math.min(width, height) / 2;
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    break;
                case 'square':
                    // Square mask
                    ctx.rect(-width/2, -height/2, width, height);
                    break;
                case 'slice':
                    // Horizontal slice
                    ctx.rect(-width/2, -height/2, width, height);
                    break;
                case 'triangle':
                    // Triangle mask
                    const h = height / 2;
                    const w = width / 2;
                    ctx.moveTo(0, -h);
                    ctx.lineTo(w, h);
                    ctx.lineTo(-w, h);
                    ctx.closePath();
                    break;
                case 'diamond':
                    // Diamond mask
                    ctx.moveTo(0, -height/2);
                    ctx.lineTo(width/2, 0);
                    ctx.lineTo(0, height/2);
                    ctx.lineTo(-width/2, 0);
                    ctx.closePath();
                    break;
                case 'hexagon':
                    // Hexagon mask
                    const radius2 = Math.min(width, height) / 2;
                    for (let i = 0; i < 6; i++) {
                        const angle = i * Math.PI / 3;
                        const x = radius2 * Math.cos(angle);
                        const y = radius2 * Math.sin(angle);
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.closePath();
                    break;
                case 'blob':
                    // Blob mask (organic shape)
                    const r = Math.min(width, height) / 2;
                    // Create an organic blob using bezier curves
                    const points = 8;
                    const angles = [];
                    const radii = [];
                    
                    // Generate random points for the blob
                    for (let i = 0; i < points; i++) {
                        angles.push((Math.PI * 2 * i) / points);
                        // Random radius between 0.5 and 1.0 of the total radius
                        radii.push(r * (0.5 + Math.random() * 0.5));
                    }
                    
                    // Start at the first point
                    const startX = Math.cos(angles[0]) * radii[0];
                    const startY = Math.sin(angles[0]) * radii[0];
                    ctx.moveTo(startX, startY);
                    
                    // Draw bezier curves between points
                    for (let i = 0; i < points; i++) {
                        const j = (i + 1) % points; // Next point index
                        
                        // Current and next points
                        const x1 = Math.cos(angles[i]) * radii[i];
                        const y1 = Math.sin(angles[i]) * radii[i];
                        const x2 = Math.cos(angles[j]) * radii[j];
                        const y2 = Math.sin(angles[j]) * radii[j];
                        
                        // Control points for bezier curve
                        const cp1x = x1 + (x2 - x1) * 0.2 + (Math.random() - 0.5) * r * 0.2;
                        const cp1y = y1 + (y2 - y1) * 0.3 + (Math.random() - 0.5) * r * 0.2;
                        const cp2x = x1 + (x2 - x1) * 0.8 + (Math.random() - 0.5) * r * 0.2;
                        const cp2y = y1 + (y2 - y1) * 0.7 + (Math.random() - 0.5) * r * 0.2;
                        
                        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2);
                    }
                    
                    ctx.closePath();
                    break;
                case 'cloud':
                    // Cloud-like shape
                    // Made of overlapping circles
                    const numCircles = 5;
                    const cloudRadius = Math.min(width, height) / 3;
                    
                    // First draw the center circle
                    ctx.moveTo(cloudRadius, 0);
                    ctx.arc(0, 0, cloudRadius, 0, Math.PI * 2);
                    
                    // Then add circles around it
                    for (let i = 0; i < numCircles; i++) {
                        const angle = (Math.PI * 2 * i) / numCircles;
                        const distance = cloudRadius * 0.6; // How far from center
                        const x = Math.cos(angle) * distance;
                        const y = Math.sin(angle) * distance;
                        const r = cloudRadius * (0.6 + Math.random() * 0.4);
                        
                        ctx.moveTo(x + r, y);
                        ctx.arc(x, y, r, 0, Math.PI * 2);
                    }
                    break;
                case 'polygon':
                    // Random polygon
                    const sides = 5 + Math.floor(Math.random() * 3); // 5-7 sides
                    const polyRadius = Math.min(width, height) / 2;
                    
                    for (let i = 0; i < sides; i++) {
                        const angle = (Math.PI * 2 * i) / sides;
                        // Add some randomness to the radius
                        const r = polyRadius * (0.8 + Math.random() * 0.2);
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.closePath();
                    break;
                default:
                    // Default to rectangle
                    ctx.rect(-width/2, -height/2, width, height);
            }
            
            ctx.clip();
            
            // Draw image inside mask
            if (images.length > 0) {
                const img = images[Math.floor(Math.random() * images.length)];
                const imgAspect = img.width / img.height;
                const maskAspect = width / height;
                
                let drawWidth, drawHeight, drawX, drawY;
                
                if (imgAspect > maskAspect) {
                    // Image is wider than mask
                    drawHeight = height;
                    drawWidth = height * imgAspect;
                    drawX = -drawWidth / 2;
                    drawY = -height / 2;
                } else {
                    // Image is taller than mask
                    drawWidth = width;
                    drawHeight = width / imgAspect;
                    drawX = -width / 2;
                    drawY = -drawHeight / 2;
                }
                
                // Set blend mode
                ctx.globalCompositeOperation = 'multiply';
                
                // Draw the image
                ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                
                // Reset composite operation
                ctx.globalCompositeOperation = 'source-over';
            }
            
            ctx.restore();
        }
        
        // Apply randomization to a placement
        function randomizePlacement(placement, paramRanges) {
            // Clone the placement to avoid modifying the original
            const result = { ...placement };
            
            if (!paramRanges) return result;
            
            // Position variation (x, y)
            if (paramRanges.position > 0) {
                const posRange = paramRanges.position * 0.2; // Scale down for subtle variation
                result.x = placement.x + (Math.random() * 2 - 1) * posRange;
                result.y = placement.y + (Math.random() * 2 - 1) * posRange;
                
                // Clamp values to valid range
                result.x = Math.max(0, Math.min(1 - placement.width, result.x));
                result.y = Math.max(0, Math.min(1 - placement.height, result.y));
            }
            
            // Size variation (width, height)
            if (paramRanges.size > 0) {
                const sizeRange = paramRanges.size * 0.15; // Scale down for subtle variation
                result.width = placement.width * (1 + (Math.random() * 2 - 1) * sizeRange);
                result.height = placement.height * (1 + (Math.random() * 2 - 1) * sizeRange);
                
                // Ensure minimum size
                result.width = Math.max(0.05, result.width);
                result.height = Math.max(0.05, result.height);
                
                // Ensure maximum size
                result.width = Math.min(0.9, result.width);
                result.height = Math.min(0.9, result.height);
            }
            
            // Rotation variation
            if (paramRanges.rotation > 0 && placement.rotation !== undefined) {
                const rotRange = paramRanges.rotation * 30; // Scale to degrees (e.g. 0.5 -> 15 degrees)
                result.rotation = placement.rotation + (Math.random() * 2 - 1) * rotRange;
            }
            
            return result;
        }
        
        // Function to generate template
        function generateTemplate() {
            const templateKey = templateSelect.value;
            const template = abstractTemplates.find(t => t.key === templateKey);
            
            if (template) {
                // Save current template
                currentTemplate = template;
                
                // Update template info
                templateName.textContent = template.name;
                templateDescription.textContent = template.description || '';
                templateData.textContent = JSON.stringify(template, null, 2);
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Fill with background color
                ctx.fillStyle = template.defaultBG || '#FFFFFF';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw each placement with randomization
                template.placements.forEach(placement => {
                    // Apply randomization
                    const randomized = randomizePlacement(placement, template.paramRanges);
                    
                    // Convert relative coordinates to actual canvas coordinates
                    const x = randomized.x * canvas.width;
                    const y = randomized.y * canvas.height;
                    const width = randomized.width * canvas.width;
                    const height = randomized.height * canvas.height;
                    
                    // Draw the mask
                    drawMask(randomized.maskName, x, y, width, height, randomized.rotation);
                });
                
                console.log('Generated template:', template.key);
            } else {
                console.error('Template not found:', templateKey);
            }
        }
        
        // Record feedback
        function recordFeedback(isPositive) {
            if (!currentTemplate) return;
            
            // Create feedback entry
            const feedback = {
                templateKey: currentTemplate.key,
                timestamp: new Date().toISOString(),
                isPositive: isPositive,
            };
            
            // Add to history
            feedbackHistory.push(feedback);
            
            console.log('Feedback recorded:', feedback);
            
            // Generate a new version
            generateTemplate();
        }
        
        // Download feedback history
        function downloadFeedback() {
            if (feedbackHistory.length === 0) return;
            
            // Create downloadable JSON
            const dataStr = "data:text/json;charset=utf-8," + 
                encodeURIComponent(JSON.stringify(feedbackHistory, null, 2));
            
            // Create download link
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "template-feedback.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }
        
        // Populate template select
        abstractTemplates.forEach(template => {
            const option = document.createElement('option');
            option.value = template.key;
            option.textContent = template.name;
            templateSelect.appendChild(option);
        });
        
        // Event listeners
        generateBtn.addEventListener('click', generateTemplate);
        templateSelect.addEventListener('change', generateTemplate);
        feedbackGood.addEventListener('click', () => recordFeedback(true));
        feedbackBad.addEventListener('click', () => recordFeedback(false));
        
        // Create download button
        const downloadBtn = document.createElement('button');
        downloadBtn.textContent = 'Download Feedback Data';
        downloadBtn.style.marginTop = '20px';
        downloadBtn.addEventListener('click', downloadFeedback);
        document.querySelector('.template-info').appendChild(downloadBtn);
        
        // Load images
        loadImages();
    </script>
</body>
</html>
